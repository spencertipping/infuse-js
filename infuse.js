// Infuse core | Spencer Tipping
// Licensed under the terms of the MIT source code license

// Introduction.
// All Infuse objects support a large set of core methods. Many of these methods
// are implemented in terms of other, type-specific methods; for example, `each`
// is a type-specific method that is used for `all` and `any`. This file defines
// the global `infuse` function and the mechanism used to define type-specific
// infuse implementations.

(function () {
  var original_infuse = typeof infuse !== typeof void 0 ? infuse : undefined;

  var dispatcher = function (name) {
    var result = function (x) {
      for (var xs = result.alternatives, i = xs.length - 1, t; i >= 0; --i)
        if ((t = xs[i]).accepts.apply(t, arguments))
          return t.construct.apply(t, arguments);
      throw new Error(
        name + '(' + Array.prototype.slice.call(arguments).join(', ')
             + ') is not supported (no alternative accepted the supplied '
             + 'arguments)');
    };

    result.alternatives = [];
    result.accepts = function (x) {
      for (var xs = result.alternatives, i = xs.length - 1, t; i >= 0; --i)
        if ((t = xs[i]).accepts.apply(t, arguments))
          return true;
      return false;
    };

    return result;
  };

  var infuse_global = dispatcher('infuse');
  infuse_global.dispatcher = dispatcher;

  infuse_global.hide = function () {
    infuse = original_infuse;
    original_infuse = null;
    delete infuse_global.hide;
    return infuse_global;
  };

  infuse_global.unloaders = [];
  infuse_global.unload = function () {
    for (var xs = infuse_global.unloaders, i = 0, l = xs.length; i < l; ++i)
      xs[i]();
  };

  infuse = infuse_global;
})();

// Bind a local variable so that extend() works even after hiding the global.
(function (infuse) {
  infuse.extend = function (body) {
    return body.call(infuse, infuse, infuse.prototype) || infuse;
  };
})(infuse);

infuse.extend(function (infuse) {

// Infuse function instantiation.
// We don't really advertise this because it isn't generally useful, but you can
// instantiate the global Infuse object as a class to enable prototype
// inheritance. Infuse uses this internally when you define new types.

var as_ctor = {};
infuse.alternatives.push(
  {accepts:   function (x) {return x === as_ctor},
   construct: function ()  {}});

// Methods and type definition.
// All global methods are installed on `infuse.prototype`. Subclasses then inherit
// from `infuse` using the usual Javascript inheritance pattern.

infuse.type = function (name, body) {
  var ctor = infuse[name] = function () {
    if (this.constructor !== ctor) {
      var result = new ctor();
      result.initialize.apply(result, arguments);
      return result;
    }
  };
  (ctor.prototype = new infuse(as_ctor)).constructor = ctor;
  return body.call(ctor, ctor, ctor.prototype) || ctor;
};

infuse.mixins = {};
infuse.mixin = function (name, body) {
  var methods = {};
  body.call(methods, methods);

  return infuse.mixins[name] = function (proto) {
    // Mix methods into proto.
    for (var k in methods)
      if (Object.prototype.hasOwnProperty.call(methods, k))
        proto[k] = methods[k];
    return proto;
  };
};

// Infuse object passthrough.
// If you invoke `infuse()` on something that is already an Infuse object, the
// object is returned verbatim. This allows you to transparently promote
// non-Infuse objects.

infuse.alternatives.push(
  {accepts:   function (x) {return x instanceof infuse},
   construct: function (x) {return x}});

});

// Generated by SDoc
// Infuse pull-propagation mixin | Spencer Tipping
// Licensed under the terms of the MIT source code license

// Introduction.
// All Infuse collections support some form of derivatives and dynamic updating.
// This mixin assumes the presence of a few instance variables and provides the
// methods required to create linked derivatives. To use this mixin, you need to
// define/maintain the following:

// | this.base_            the source for this derivative collection
//   this.generator_       a generator function that accepts an emitter
//   this.version_         the current version of this object
//   this.push_(v, k)      a function that adds a new element to the object

// Given that, this mixin provides a complete implementation of pull-propagation,
// as well as defining a wrapper `push` method that takes care of version
// updating and derivative checking.

infuse.extend(function (infuse) {
infuse.mixin('pull', function (methods) {

// Trivial accessors.
// We assume the presence of `base_`, `version_`, and `generator_`. Of these,
// `generator_` is kept private because accessing it changes its state.

methods.base    = function () {return this.base_};
methods.version = function () {return this.version_};

// Pull propagation.
// You can pull any collection with a base (it's a nop for independent
// collections). An invariant is that invoking `pull` with no arguments will cause
// the receiver to become up-to-date with the base. As a result, the receiver's
// version will bet set equal to the base's version.

methods.pull = function () {
  var b = this.base_,
      v = b && b.pull().version();

  // Invoking generators is potentially expensive, so only do it if there's a
  // version discrepancy.
  if (v && v > this.version_) {
    // Optimistically pre-increment the version so that any push_ calls made by
    // the generator will see the new version.
    ++this.version_;
    var self = this;
    this.generator_(function (v, k) {self.push_(v, k)}, this.id());
    this.version_ = v;
  }

  return this;
};

methods.push = function (v, k) {
  infuse.assert(!this.base_, 'infuse: attempted to push onto a derivative');
  ++this.version_;
  return this.push_(v, k);
};

// Detaching.
// You can detach any pull-propagated collection from its source to allow the
// source to be garbage-collected. Doing this also enables the collection to be
// modified by using `push`. `detach` does nothing if the collection is already
// detached.

methods.detach = function () {
  if (this.base_) this.base_.detach_derivative(this);
  this.base_ = this.generator_ = null;
  return this;
};

// Do nothing; we don't track derivatives.
methods.detach_derivative = function (derivative) {
  return this;
};

});
});

// Generated by SDoc
// Infuse push-propagation mixin | Spencer Tipping
// Licensed under the terms of the MIT source code license

// Introduction.
// This mixin provides method implementations useful for push-updated objects. The
// assumption is that push updates happen asynchronously, though they could also
// be synchronous in certain cases.

infuse.extend(function (infuse) {
infuse.mixin('push', function (methods) {

// Compatibility.
// It's legal to use a push collection as the basis for a pull collection, and
// this actually happens quite frequently. To make this work, we need to implement
// two methods: `pull` (which does nothing), and `version`. A push-propagated
// object's version is just its size; presumably this is monotonically increasing
// (if not, you should define a different version strategy).

methods.pull    = function () {return this};
methods.version = function () {return this.size() + 1};

// Detachment.
// Push objects are forward-linked, so we need to inform the parent that the
// derivative should be detached. In order to do this, we need to construct a
// unique identifier for each derivative.

methods.detach = function (base) {
  // Two possibilities. If a base is specified, then detach from that one
  // specifically. Otherwise, detach from all bases.
  if (base)
    base.detach_derivative(this),
    delete this.bases_[base.id()];
  else {
    var bs = this.bases_;
    for (var id in bs)
      if (Object.prototype.hasOwnProperty.call(bs, id))
        bs[id].detach_derivative(this),
        delete bs[id];
  }
  return this;
};

methods.detach_derivative = function (derivative) {
  // Free the listener if possible.
  var ls = this.listeners_;
  if (ls) delete ls[derivative.id()];
  return this;
};

});
});

// Generated by SDoc
// Infuse funnels | Spencer Tipping
// Licensed under the terms of the MIT source code license

// Infuse funnels.
// A funnel is a virtual object that unifies multiple bases. It maintains no
// state, and as such has no `get` method.

infuse.extend(function (infuse) {
infuse.type('funnel', function (funnel, methods) {

// Although funnels are structurally pull-collections, we don't mixin the pull
// collection base here. The pull-collection base assumes just one base, but
// funnels have many. Funnels also don't store versions; the funnel's version is
// just the sum of the versions of its bases.

methods.initialize = function (bases) {
  this.bases_ = bases;
};

methods.version = function () {
  for (var v = 0, i = 0, bs = this.bases_, l = bs.length; i < l; ++i)
    v += bs[i].version();
  return v;
};

// Funnels maintain no real state, so pulling does nothing. Changes are always
// propagated from generators.

methods.pull = function () {return this};

// Derivatives.
// Funnels don't support derivatives, but they do provide generators.

methods.derivative = function () {
  throw new Error('infuse: funnels cannot produce derivatives');
};

methods.generator = function () {
  var generators = [],
      versions   = [],
      self       = this;
  for (var i = 0, bs = this.bases_, l = bs.length; i < l; ++i)
    generators.push(bs[i].generator()),
    versions.push(-1);

  return function (emit, id) {
    var v  = 0,
        bs = self.bases_;
    if (bs)
      for (var i = 0, l = versions.length; i < l; ++i)
        if ((v = bs[i].pull().version()) > versions[i])
          versions[i] = v,
          generators[i](emit, id);
  };
};

methods.detach = function () {
  for (var i = 0, bs = this.bases_, l = bs.length; i < l; ++i)
    bs[i].detach_derivative(this);
  this.bases_ = null;
  return this;
};

methods.detach_derivative = function (derivative) {
  return this;
};

});
});

// Generated by SDoc
// Infuse cells | Spencer Tipping
// Licensed under the terms of the MIT source code license

// Infuse cell.
// A cell is just a box for a value. The whole purpose is to contain a single
// value and update it lazily with the same semantics that other Infuse objects
// have. Cells are used to compute constant-space intermediate reductions of
// things, for example. See the `reduction` method for an example of this.

infuse.extend(function (infuse) {
infuse.type('cell', function (cell, methods) {

infuse.mixins.pull(methods);

// Cell state.
// Not much to this. Cells just hold a single value, and the key is just the
// version.

methods.initialize = function (x_or_f, base) {
  if (base)
    this.x_         = null,
    this.generator_ = x_or_f,
    this.base_      = base,
    this.version_   = -1;
  else
    this.x_         = x_or_f,
    this.generator_ = null,
    this.base_      = null,
    this.version_   = 1;
};

methods.size = function () {return 1};

methods.push_ = function (v, k) {
  this.x_ = v;
  return this;
};

methods.derivative = function (generator, version_base) {
  var f = infuse.fn(generator);
  return infuse.cell(f, version_base || this);
};

methods.generator = function () {
  var last_v = 0, self = this;
  return function (emit) {
    if (last_v !== (last_v = self.version()))
      emit(self.x_, last_v);
  };
};

methods.get = function () {
  this.pull();
  if (!arguments.length) return this.x_;
  return this.default_get.apply(this, arguments);
};

});
});

// Generated by SDoc
// Infuse utilities | Spencer Tipping
// Licensed under the terms of the MIT source code license

// Introduction.
// This module defines global functions on the `infuse` global.

infuse.extend(function (infuse) {

// Function constructors.
// Various commonly-used functions.

infuse.identity = function (x) {return x};
infuse.id       = infuse.identity;

infuse.always     = function (x) {return function () {return x}};
infuse.constantly = infuse.always;
infuse.k          = infuse.always;

infuse.tap = function (v, fn) {
  infuse.fnarg(arguments, 1)(v);
  return v;
};

// Future constructors.
// Futures can be hard to work with on their own, so Infuse gives you some ways of
// wrapping them and combining their values.

infuse.immediate = function (v, k) {return infuse.future().push(v, k)};

// The `await` function is most useful when you have multiple futures running
// concurrently and want to wait for all of them to come back. It takes an object,
// array, or Infuse collection whose values may include futures and returns a
// future of a similarly-structured result whose values are all non-futures. That
// is, it transposes the future-ness of the values of some collection across the
// collection itself.

// Note that awaiting a collection of futures ignores the futures' keys. You can
// specify a keygate, however.

infuse.await = function (xs, keygate) {
  var wrapped   = xs === (xs = infuse(xs)),
      keygate   = infuse.keygate(keygate),
      root      = infuse.immediate(xs.zero()),
      collector = xs.reduce(root, function (base, v, k) {
        return v instanceof infuse.future || v instanceof infuse.signal
          ? base.flatmap(function (result) {
              // once() is used to collapse signals into futures. More than one
              // result would trigger an error, since we're flatmapping into a
              // future.
              return v.once(keygate).map(function (v) {
                return result.push(v, k);
              });
            })
          : base.map(function (result) {return result.push(v, k)});
      });

  return collector.map(function (result) {
    return wrapped ? result : result.get();
  });
};

// Similar to `await` is `progress`, which gives you a signal of reductions as the
// individual futures complete. It supports signal values, not just future values,
// and the reduction is updated each time one of the signals changes. You can
// think of `await` as intersecting futures/signals and `progress` as unioning
// them.

infuse.progress = function (xs, keygate) {
  var wrapped = xs === (xs = infuse(xs)),
      keygate = infuse.keygate(keygate),
      root    = infuse.signal().push(xs.zero()),
      union   = xs.reduce(root, function (base, v, k) {
        var f = v instanceof infuse.future || v instanceof infuse.signal
                ? v
                : infuse.immediate(v);
        f.generator()(function (v, inner_k) {base.push(base.get().push(v, k))},
                      base.id());
        return base;
      });

  return union.map(function (result) {
    return wrapped ? result : result.get();
  });
};

// Infuse gives you a global `on` function to unify futures and non-futures. If
// `v` is a future or signal, then `callback` will be invoked once it is resolved;
// otherwise `callback` is invoked synchronously on the value. In the latter case,
// `callback` receives no key, just a value.

infuse.on = function (v, keygate, callback) {
  return v instanceof infuse.future || v instanceof infuse.signal
    ? v.once(keygate, callback)
    : callback(v);
};

// Ordering functions.
// These are useful when you're sorting things. All elements are considered
// distinct for orderings, so a â‰® a.

infuse.comparator_to_ordering = function (comparator) {
  return function (x, y) {return comparator(x, y) < 0};
};

infuse.comparator_from_ordering = function (ordering) {
  return function (x, y) {return ordering(x, y) ? -1 : 1};
};

// Internal functions.
// These are generally just used by Infuse.

var id = 0;
infuse.gen_id = function () {return 'infuse-' + ++id};

infuse.toa   = function (xs)    {return Array.prototype.slice.call(xs)};
infuse.slice = function (xs, n) {return Array.prototype.slice.call(xs, n)};

infuse.fnarg = function (args, i) {
  // Make a function from arguments[i] and beyond. O(n) in the number of
  // arguments, though in most cases the GC overhead probably outweighs the
  // complexity.
  return infuse.fn.apply(this, infuse.slice(args, i));
};

infuse.assert = function (x, message) {
  if (!x) throw new Error(message);
  return x;
};

infuse.assert_equal = function (x, y) {
  infuse.assert(x === y, x + ' != ' + y);
  return x;
};

infuse.msb = function (x) {
  // Index of most-significant bit of x, where msb(1) = 0.
  for (var lower = 0, upper = 64; lower + 1 < upper;) {
    var mid     = lower + upper >>> 1,
        shifted = x >>> mid;
    if (shifted && shifted !== x) lower = mid;
    else                          upper = mid;
  }
  return lower;
};

});

// Generated by SDoc
// Infuse heapmap | Spencer Tipping
// Licensed under the terms of the MIT source code license

// Introduction.
// A fairly trivial minheap-map implementation used by the cache as a priority
// queue. This heap stores objects independently from their priorities, so you can
// update an object's priority dynamically and it will heapify up or down
// accordingly.

// Like other Infuse collections, heap maps support lazy derivatives. Unlike other
// collections, however, heaps are not append-only. This makes lazy derivatives
// interesting, as we might need to update any element at any point.

// To deal with this, a heap generator doesn't follow the same rules that other
// generators do. Instead, its guarantee is that successively emitted elements
// will have increasing heap indexes (so they are descending in the heap). The
// generator tracks the last heap index emitted and emits elements greater than
// that.

// A nice result of doing things this way is that you can (reasonably) efficiently
// use a heap generator to implement an update journal (see `infuse.object` for an
// example).

infuse.extend(function (infuse) {
infuse.type('heapmap', function (heapmap, methods) {

// Enable pull-propagation updating
infuse.mixins.pull(methods);

// Heap state.
// A heap stores the ordering function, which takes two elements and returns true
// if the first should be above the second (so for a minheap, `a < b`). It also
// contains the element set, an internal map that keeps track of where each
// element is stored in the array.

// Heapmaps are maps, so you can't store arbitrary data in them (well, you can I
// guess, but then the map will break). If you want the map functionality, then
// the data you're storing must be a string.

methods.initialize = function (above, generator, base) {
  this.above_     = above ? infuse.fn.apply(this, arguments)
                          : function (a, b) {return a < b};
  this.xs_        = [null];             // stores heap indexes (values)
  this.keys_      = [null];             // stores entry keys
  this.map_       = {};                 // maps keys to array indexes
  this.version_   = -1;
  this.base_      = base;
  this.generator_ = generator;

  infuse.assert(!!base === !!generator,
    'infuse: base and generator must be specified together ('
  + 'error constructing heapmap)');
};

methods.size = function () {return this.pull().xs_.length - 1};

// Derivatives.
// Heap maps are interesting because they're mutable, which violates an assumption
// that Infuse makes about viewable collections (i.e. things with derivatives).
// Normally this would disqualify heapmaps from being Infuse collections at all,
// but in this case we can work around it by changing the semantics of appending.
// Rather than considering objects over time, we use heap ordering of objects.
// This logic is explained further in the `generator` method.

methods.derivative = function (generator, version_base) {
  var f = infuse.fn.apply(this, arguments);
  return infuse.heapmap(this.above_, f, version_base || this);
};

// Traversal.
// Heaps are traversed in heap-sorted order, which means that each generator
// requires an extra O(log n) time to identify the next child. This is a
// data-recursive process: the generator maintains a heap of child entries. Here's
// what is going on:

// |                       5               <- heap root; we start here
//                       /   \
//                     9       8
//                   /  \     /
//                 40    10  9

// The user asks for a generator of the heap. We're required to present them with
// a sorted list of keys, which we do by nondestructively traversing the heap
// downwards:

// |                     c(5)              <- emit 5
//                     /      \
//                   9          8          <- push children onto a heap

// There are two sub-heaps after we emit 5, and in general because of the freedom
// in the heap property there could be O(n) subheaps that we need to worry about.
// We need the minimum of all subheaps. So, like any computer scientist should, we
// allocate another heap to keep track of the subheaps:

// |                    8                  <- the generator's heap; 8 is next
//                     /
//                    9

// Then each generator fetch is just a matter of returning the minimum element of
// its heap and pushing the heap's children.

methods.generator = function () {
  var self = this;

  var limit      = null,                // updated by the generator
      have_limit = false;

  return function (emit, id) {
    var xs   = self.pull().xs_,
        keys = self.keys_,
        l    = xs.length;

    if (l <= 1) return;                 // nothing to do (yet)

// First step: check to see whether we have any nodes that satisfy the ceiling
// property. If not, then we're done.

    var depth   = infuse.msb(l - 1),
        initial = have_limit ? self.initial_ceiling_(limit, depth)
                             : 1;

    if (initial === null) return;       // nothing to do (no initial ceiling)

// We have to rebuild the next-child heap each time the generator is called.
// Otherwise we might not catch modifications made to the heap between generator
// calls. Like other generators, we disallow comodification; you must exit the
// generator by returning false before you modify the collection it's traversing.

    var child_selector = infuse.heapmap(self.above_),
        initial_v      = self.version_;

// Populate the child selector. We need to fully traverse the ceiling before we
// know which element to choose next (actually, this isn't quite true if we see
// something that equals the limit; but coding for referential equality is not
// really appropriate).

    for (var i = initial, x;
         i !== null;
         i = self.next_ceiling_(limit, i, depth))
      child_selector.push(x = xs[i], i);

// Now start emitting stuff. Push the children of each element we pull until there
// are no children left.

    while (child_selector.size()) {
      var i = +child_selector.pop(),
          x = xs[i];

      limit      = x;
      have_limit = true;
      if (emit(limit = xs[i], keys[i]) === false) return;

      var left = i << 1;
      if (left < l) {
        child_selector.push(xs[left], left);
        var right = left + 1;
        if (right < l) child_selector.push(xs[right], right);
      }
    }
  };
};

// Ceiling generation.
// A ceiling node is defined as an inclusive lower bound for a value. We refer to
// them by indexes within `xs`. The goal is usually to generate all ceilings for a
// given value bound.

// This is used when re-entering a generator. We pass in the minimum (topmost)
// value we're looking for and the index of the heap node we're starting with
// (generally the `initial_ceiling_` for the first call), and `next_ceiling_`
// returns the index of the next node we should look at. If there are no more
// elements, `next_ceiling_` returns `null`.

// The traversal order from this function is left-to-right within the tree
// representation of a heap. This means that there is no ordering among ceilings.

methods.next_ceiling_ = function (v, i, depth) {
  if (!(i & i + 1)) return null;                // no more elements on level

  var xs = this.xs_, l = xs.length;
  if (i + 1 >= l)                               // we may be on a jagged leaf
    if (!((i >>>= 1) & i + 1))                  // ... but if not, then
      return null;                              // ... we're done

// Are we moving from a left to a right child? If so, we know we can't go up since
// otherwise the left child wouldn't have been the topmost ceiling.

  var search_upwards = i & 1;                   // right child before moving?
  ++i;                                          // if so, now we're at a left

// At this point we're at a node that may or may not be top-enough to be a valid
// ceiling. Handle the easy case first:

  if (this.above_(v, xs[i]))
    // The node is a valid ceiling, so up-search if necessary and return it.
    return search_upwards ? this.topmost_ceiling_(v, i, depth) : i;

// This case is more interesting. The new node isn't a valid ceiling, so we need
// to do a leaf-search and then move upwards from the first leaf that works. If no
// leaf, then we return null.

// This loop scans right until either we hit the end of the level, or we hit the
// end of the array. In the latter case we need to move up one level and continue
// scanning there.

  for (i <<= depth - infuse.msb(i); i & i - 1 && i < l; ++i)
    if (this.above_(v, xs[i]))
      return this.topmost_ceiling_(v, i, depth);

// This loop handles the level above. If we had hit the end of the last level,
// this loop will do nothing.

  for (i >>>= 1, l = 1 << depth; i < l; ++i)
    if (this.above_(v, xs[i]))
      return this.topmost_ceiling_(v, i, depth);

// We hit the end without finding a suitable leaf, so we're done.

  return null;
};

// Binary search to identify the topmost node that satisfies the ceiling property.
// This requires O(log log n) ordering checks (which I'm assuming are arbitrarily
// expensive).

methods.topmost_ceiling_ = function (v, i, depth) {
  var xs = this.xs_;
  for (var lower = 0, upper = depth; lower + 1 < upper;) {
    var mid = lower + upper >>> 1;
    if (this.above_(v, xs[i >>> mid])) lower = mid;
    else                               upper = mid;
  }
  return i >>> lower;
};

// Find the first leaf with the ceiling property, then find its topmost ceiling.
// This is the only strategy we can use and still know that we have the leftmost
// ceiling. If there is no initial ceiling, then `initial_ceiling_` returns
// `null`.

methods.initial_ceiling_ = function (v, depth) {
  var xs = this.xs_;

  // Start on the leaf level...
  for (var i = 1 << depth, second_limit = i, limit = xs.length; i < limit; ++i)
    if (this.above_(v, xs[i]))
      return this.topmost_ceiling_(v, i, depth);

  // ... and continue one level above that if we don't find anything. (We do
  // this because the bottom layer of leaves might not be complete.)
  for (i >>>= 1; i < second_limit; ++i)
    if (this.above_(v, xs[i]))
      return this.topmost_ceiling_(v, i, depth);

  return null;
};

methods.get = function (k) {
  var map = this.map_;
  if (typeof k === typeof '' || k instanceof String)
    return this.xs_[map[k]];
  return this.get_default.apply(this, arguments);
};

methods.remove = function (k) {
  infuse.assert(!this.base_,
    'infuse: attempted to remove() from a derivative heapmap (because '
  + 'the heap map is a derivative, modifying it directly is illegal)');

  var xs   = this.xs_,
      map  = this.map_,
      keys = this.keys_;
  if (xs.length <= 1) return void 0;    // can't remove from an empty heap

  if (xs.length > 2)
    xs[1]   = xs.pop(),                 // standard last->first...
    keys[1] = keys.pop();
  else
    xs.pop(), keys.pop();               // first is last, so just pop

  if (xs.length > 1) {
    map[keys[1]] = 1;                   // update position map
    this.heapify_down_(1);              // then heapify down
  }

  delete map[k];
  ++this.version_;                      // record the change
  return this;
};

methods.pop = function () {
  var ks = this.keys_;
  if (ks.length <= 1) return void 0;
  var k = ks[1];
  this.remove(k);
  return k;
};

methods.peek = function () {
  return this.keys_[1];
};

methods.push_ = function (v, k) {
  var xs   = this.xs_,
      keys = this.keys_,
      map  = this.map_;

  if (Object.prototype.hasOwnProperty.call(map, k)) {
    // Update, not insert. Change the value, then heapify up or down
    // depending on the value ordering.
    var i = map[k],
        x = xs[i];
    xs[i] = v;
    return this.above_(v, x) ? this.heapify_up_(i)
                             : this.heapify_down_(i);
  } else {
    // Insert. This is the easy case: build a new container, add to end of
    // elements, and heapify up.
    var l = xs.length;
    xs.push(v);
    keys.push(k);
    return this.heapify_up_(map[k] = l);
  }
};

methods.swap_ = function (i, j) {
  var xs   = this.xs_,
      keys = this.keys_,
      map  = this.map_,
      tmp  = xs[i];
  xs[i] = xs[j];                        // swap the elements
  xs[j] = tmp;
  tmp = keys[i];                        // ... and the keys
  keys[i] = keys[j];
  keys[j] = tmp;
  map[keys[i]] = i;                     // update position map
  map[keys[j]] = j;
  return this;
};

methods.heapify_down_ = function (i) {
  var xs = this.xs_,
      l  = xs.length;

  if (i << 1 >= l)
    // Can't heapify down beyond the bottom of the heap
    return this;

  // Swap with the greater of the two children unless the current element is
  // greater than both.
  var left  = i << 1,
      right = left | 1,
      xi    = xs[i],
      xl    = xs[left],
      xr    = xs[right];      // this might not exist

  if (this.above_(xi, xl) && (right >= l || this.above_(xi, xr)))
    // We're done; neither child is greater.
    return this;

  // Swap with the greater of the two children.
  var swap_index = right >= l || this.above_(xl, xr) ? left : right;
  return this.swap_(i, swap_index).heapify_down_(swap_index);
};

methods.heapify_up_ = function (i) {
  var xs = this.xs_,
      up = i >>> 1;
  return up && this.above_(xs[i], xs[up])
    ? this.swap_(i, up).heapify_up_(up)
    : this;
};

});
});

// Generated by SDoc
// Infuse caches | Spencer Tipping
// Licensed under the terms of the MIT source code license

// Introduction.
// This module defines various kinds of caches for Infuse. These are used
// internally in cases where a weak reference map would ordinarily be used; for
// instance, caching compiled functions.

infuse.extend(function (infuse) {

infuse.cache = function (eviction_strategy) {
  var cache = {},       // cache data
      state = {};       // eviction strategy state
  eviction_strategy = eviction_strategy || infuse.cache.lru();
  var result = function (obj, generate) {
    return eviction_strategy(result, cache, state, obj, generate);
  };
  result(null, null);   // initialize the cache
  return result;
};

// Eviction strategies.
// An eviction strategy is notified whenever an entry is created, accessed, added,
// or removed from the cache. It then, potentially asynchronously, acts on the
// cache object to evict something if necessary. The eviction strategy owns the
// cache object exclusively; no user of the cache has access to it.

//   LRU eviction.
//   This is the most straightforward. We just keep a simple mapping from key to
//   access-time, and maintain a priority queue of evictable elements. This makes
//   cache access O(log n) in the number of elements, which is bounded above by
//   the cache capacity.

//   LRU eviction allows the user to evict an element at any point by calling the
//   `evict_one` method on the cache object. This can be useful if you want to
//   simulate weak references by slowly freeing memory over time, for instance.

  infuse.cache.lru = function (options) {
    options = options || {};
    var capacity = options.capacity || 1000,
        evict    = function (cache, state) {
          // Do nothing if there are no elements.
          if (!state.size) return false;
          --state.size;
          return delete cache[state.priority_queue.pop()];
        },
        clear    = function (cache, state) {
          for (var k in cache) delete cache[k];
          while (state.priority_queue.size()) state.priority_queue.pop();
          state.size = 0;
        };

    return function (f, cache, state, key, generate) {
      // Initialize the state if necessary. This happens before any objects are
      // inserted into the cache.
      if (key === null && generate === null) {
        state.size           = 0,
        state.access_counter = 0,
        state.priority_queue = infuse.heapmap(),
        f.hits               = 0,
        f.evictions          = 0,
        f.misses             = 0,
        f.evict_one          = function () {return evict(cache, state)},
        f.clear              = function () {return clear(cache, state)};
        return null;
      }

      // Prefix the key with something not used by Javascript. Otherwise we
      // risk colliding with native methods like Object.prototype.toString.
      key = '@' + key;

      // First, determine whether we have the item. If we do, just update the
      // access time and take no further action.
      if (Object.prototype.hasOwnProperty.call(cache, key)) {
        ++f.hits;
        state.priority_queue.push(++state.access_counter, key);
        return cache[key];
      }

      // Cache miss, so go ahead and generate a value and insert the result.
      // If we're over capacity, evict the least-recent access, which will be
      // the top element in the priority queue.
      var value = generate(key);
      ++f.misses;
      if (++state.size > capacity) {
        ++f.evictions;
        evict(cache, state);
      }
      state.priority_queue.push(++state.access_counter, key);
      return cache[key] = value;
    };
  };

});

// Generated by SDoc
// Infuse function promotion | Spencer Tipping
// Licensed under the terms of the MIT source code license

// Introduction.
// Javascript's function syntax is verbose, so Infuse supports implicit function
// promotion. This means that any method expecting a function can also accept
// other values like regular expressions or strings, and Infuse will produce a
// function from these other values.

// All Infuse extensions are written using `infuse.extend`. This binds a local
// variable `infuse` that won't change even if the user calls `infuse.hide()`
// (which removes the global reference).

infuse.extend(function (infuse) {

infuse.fn       = infuse.dispatcher('infuse.fn');
infuse.fn.cache = infuse.cache(infuse.cache.lru({capacity: 2048}));

// Automatic fn cache GC.
// If you have a long-running application that uses dynamically-generated
// functions, you may want to enable this. In most cases it won't matter much
// because the cache has a hard upper bound.

infuse.fn.auto_gc = function () {
  // Automatically clear out the function cache over time. There is no reason
  // to do this very quickly, since compiled functions don't hold any large
  // references (i.e. they aren't closures over user-specified data).
  //
  // In general it isn't safe to use intervals to control caches, since the
  // interval is a global reference that will prevent the whole cache from
  // being garbage-collected. However it is reasonable in this particular case
  // because the cache is already a global object.
  infuse.fn.cache_interval = setInterval(infuse.fn.cache.evict_one, 1000);

  infuse.unloaders.push(function () {
    clearInterval(infuse.fn.cache_interval);
  });
};

// Things with a `fn` method.
// Any object that defines a `fn` method will be promoted into a function using
// that method. Because Infuse objects support `fn`, we also try promoting the
// object into an Infuse collection and using its `fn` method.

infuse.fn.alternatives.push(
  {accepts:   function (x) {return true},
   construct: function (x) {var i = infuse.apply(this, arguments);
                            return i.fn.apply(i, infuse.slice(arguments, 1))}});

infuse.fn.alternatives.push(
  {accepts:   function (x) {return x && x.fn instanceof Function},
   construct: function (x) {return x.fn.apply(x, infuse.slice(arguments, 1))}});

// Regular expressions.
// Regular expression functions return either a match object (for regexps with
// no capturing groups), or strings (for regexps with one or more capturing
// groups).

// | infuse.fn(/foo/)      -> function (x) {return /foo/.exec(x)}
//   infuse.fn(/f(o)o/)    -> function (x) {
//                              var result = /f(o)o/.exec(x);
//                              return result && result[1];
//                            }
//   infuse.fn(/foo/g)     -> function (x) {return x.match(/foo/g) || []}

// Regexps are most useful when used on sequences of strings:
// `infuse(...).map(/f(.)o/)`.

infuse.fn.alternatives.push(
  {accepts:   function (x) {return x.constructor === RegExp},
   construct: function (regexp) {
     return infuse.fn.regexp_is_g(regexp)
       ? function (x) {return regexp.match(x) || []}
       : infuse.fn.regexp_group_count(regexp)
         // We have match groups; return them as an array.
         ? function (x) {
             var result = regexp.exec(x);
             return result && Array.prototype.slice.call(result, 1);
           }

         // No match groups; just return the matched string.
         : function (x) {
             var result = regexp.exec(x);
             return result && result[0];
           };
   }});

infuse.fn.regexp_is_g = function (regexp) {
  return /\/[^\/]*g[^\/]*$/.test(regexp.toString());
};

infuse.fn.regexp_group_count = function (regexp) {
  // Simple regexp parse: look for unescaped open-parens that aren't followed
  // by ?.
  for (var s = regexp.toString(),  groups     = 0,     group_check = -1,
           l = s.lastIndexOf('/'), escape     = false,
           i = 1,                  char_class = false, c;
       i < l; ++i) {
    c = s.charCodeAt(i);
    if      (escape)   escape = false;
    else if (c === 92) escape = true;                         // 92 = \
    else if (c === 93) char_class = false;                    // 93 = ]
    else if (char_class);
    else if (c === 91) char_class = true;                     // 91 = [
    else if (c === 40) group_check = i + 1, ++groups;         // 40 = (
    else if (i === group_check && c === 63) --groups;         // 63 = ?
  }
  return groups;
};

// Strings.
// There are two possibilities for strings. If the string begins with `[` or
// `.`, then it's assumed to be an object traversal path; otherwise it's
// compiled into a function. In the latter case, a second argument can be
// specified to bind closure variables. Function compilation is expensive, so we
// use the function cache to prevent unnecessary recompilation.

infuse.fn.is_path = function (s) {return /^\./.test(s)};
infuse.fn.is_js   = function (s) {return /^[-+\/~!$\w([{'"]/.test(s)};

infuse.fn.alternatives.push(
  {accepts:   function (x) {return x.constructor === String
                                && infuse.fn.is_path(x)},
   construct: function (s) {
     return infuse.fn.cache(s, function () {
       var path = infuse.inversion.parse_path(s);
       return function (x) {
         return infuse.inversion.at(path, x);
       };
     });
   }});

infuse.fn.alternatives.push(
  {accepts:   function (x) {return x.constructor === String
                                && infuse.fn.is_js(x)},
   construct: function (s, bindings) {
     // Function body case: prepend local variables in sorted order to make
     // sure that shadowing cases are distinct in the cache. We don't cache
     // the fully-instantiated closure; instead, we allocate a new closure
     // specific to the bindings that we have.
     return infuse.fn.cache(infuse.fn.binding_prefix(bindings) + s,
       function () {
         // The bindings passed to compile() are just for reference so that
         // compile() can bake in the right local variables ...
         return infuse.fn.compile(s, bindings);
       })(bindings);          // ... and this is where we pass them in.
   }});

// Function compilation.
// Compile a function with a list of bindings. This involves converting each
// binding key into a local variable.

infuse.fn.binding_prefix = function (bindings) {
  if (!bindings) return '';
  var bindings = [];
  for (var k in bindings)
    if (Object.prototype.hasOwnProperty.call(bindings, k))
      bindings.push(k);
  return bindings.sort().join(',') + ':';
};

infuse.fn.body_arity = function (body_string) {
  // Find the underscore-variable with the largest subscript. We support up to
  // _9, where _1 (also called _) is the first argument.
  for (var formals = body_string.match(/_\d?/g) || [],
           i       = 0,
           l       = formals.length,
           max     = +!!formals.length;
       i < l; ++i)
    max = Math.max(max, +formals[i].substr(1));
  return max;
};

infuse.fn.compile = function (code, bindings) {
  var locals = [], formals = [];

  // Alias each binding into a local variable.
  for (var k in bindings)
    if (Object.prototype.hasOwnProperty.call(bindings, k))
      locals.push('var ' + k + ' = _.' + k + ';\n');

  // Now build the list of formals.
  for (var i = 0, l = infuse.fn.body_arity(code); i < l; ++i)
    formals.push('_' + (i + 1));

  return new Function(
    '_',
    locals
    + 'return function (' + formals.join(', ') + ') {\n'
      + (formals.length ? 'var _ = _1;\n' : '')
      + 'return ' + code + ';\n'
    + '};');
};

// Functions.
// If we omit this, then it becomes impossible to pass in regular functions as
// functions. Putting it at the end makes it a little faster for the no-conversion
// fast case.

infuse.fn.alternatives.push(
  {accepts:   function (x) {return x instanceof Function},
   construct: function (x) {return x}});

// Identity function.
// Infuse promotes `null` and `undefined` into the identity function.

infuse.fn.alternatives.push(
  {accepts:   function (x) {return x == null},
   construct: function (x) {return function (x) {return x}}});

});

// Generated by SDoc
// Infuse keygates | Spencer Tipping
// Licensed under the terms of the MIT source code license

// Introduction.
// Keygates are functions that are used to filter values based on their keys. For
// instance, futures and signals support an `on` method that allows you to observe
// their values asynchronously:

// | a_signal.on('foo', function (x) {...});

// Here, `'foo'` is a _keygate_: it is a value that is used to filter the space of
// keys that will end up triggering the callback.

// Infuse promotes all keygates with the `infuse.keygate` dispatcher. It is
// structurally similar to `infuse.fn`, and unhandled values are promoted with
// `infuse.fn`.

// All builtin keygates treat `null` and `undefined` as universal passthroughs:
// these will always be handled. Similarly, `null` and `undefined` as keygates
// will accept all keys.

infuse.extend(function (infuse) {

infuse.keygate       = infuse.dispatcher('infuse.keygate');
infuse.keygate.cache = infuse.cache(infuse.cache.lru({capacity: 2048}));

// Infuse.fn failover.
// The default action is just to promote a keygate as an Infuse fn.

infuse.keygate.alternatives.push(
  {accepts:   function () {return true},
   construct: function () {return infuse.fn.apply(this, arguments)}});

// Strings.
// A string is split into words, any of which is allowed to pass through.

infuse.keygate.words = function (words) {
  return function (k) {
    return k == null || words.indexOf(k) > -1;
  };
};

infuse.keygate.alternatives.push(
  {accepts:   function (x) {return typeof x === typeof ''
                                || x instanceof String},
   construct: function (s) {
     return infuse.keygate.cache(s, function () {
       return infuse.keygate.words(s.split(/\s+/));
     });
   }});

// Catch-alls.
// `null` and `undefined` turn into catch-alls. This is to support easy grabbing
// of all keys: `sig.on(null, f)`.

infuse.keygate.alternatives.push(
  {accepts:   function (x) {return x == null},
   construct: function ()  {return function () {return true}}});

// Reject-alls.
// Using `false` as a keygate results in a function that accepts nothing.

infuse.keygate.alternatives.push(
  {accepts:   function (x) {return x === false},
   construct: function ()  {return function () {return false}}});

});

// Generated by SDoc
// Infuse arrays | Spencer Tipping
// Licensed under the terms of the MIT source code license

// Infuse arrays.
// Infuse gives you two options for working with arrays. You can promote an
// existing array, in which case the `force()` method will provide no new data and
// will throw an error. Alternatively, you can invoke `infuse.array()` on a
// generator function to create an array-backed lazy sequence. If you do this,
// `force()` will add elements to the end of the array if any are available.

// A secondary consequence of using a generator function is that derivative
// arrays, objects, etc, are themselves lazy. In these cases, forcing derivative
// `map`, `filter`, etc results will cause more elements to be dynamically
// generated and transformed accordingly. (Internally this happens when the `pull`
// method is called.)

infuse.extend(function (infuse) {
infuse.type('array', function (array, methods) {

// Mixins.
// Arrays are "pulling" collections: derivatives are linked to their sources, not
// the other way around.

infuse.mixins.pull(methods);

// Array state.
// Every Infuse array is backed by a Javascript array. If the backing was provided
// as a constructor argument, then we aren't allowed to modify it; so the sequence
// is considered to be definite and can't have a generator.

// Otherwise the sequence is a generated array, in which case we allocate a
// private backing and fill it as the user forces things.

methods.initialize = function (xs_or_f, base) {
  if (xs_or_f instanceof Function)
    this.xs_        = [],
    this.base_      = base,
    this.generator_ = xs_or_f,
    this.version_   = -1,
    this.pull();
  else
    this.xs_        = xs_or_f instanceof Array
                      ? xs_or_f
                      : infuse.toa(xs_or_f),
    this.base_      = null,
    this.generator_ = null,
    this.version_   = 1;
};

// Size is always expressed as the number of items currently realized, not the
// eventual size of a lazy sequence. Any given lazy sequence will be both finite
// (as its size is finite) and indefinite at the same time, and operations such as
// `map` and `flatmap` will apply eagerly to the currently-realized part.

methods.size = function () {return this.pull().xs_.length};

// We mixin the `pull` behavior, which relies on this `push_` method to actually
// add things to the array. We don't need to worry about versioning.

methods.push_ = function (v, k) {
  this.xs_.push(v);
  return this;
};

// Derivatives.
// Laziness requires that we pass on certain metadata about the base whenever we
// construct any derivative. To do this, we have the derivative link to its base
// so that any new elements on the base can be transformed accordingly.

methods.derivative = function (generator, version_base) {
  var f = infuse.fn(generator);
  return infuse.array(f, version_base || this);
};

// Traversal.
// A generator is a stateful iterator that takes an emitter function and invokes
// it once for each item in the array. It re-checks the array's size each time it
// is called, so a generator can represent a collection whose size changes over
// time.

methods.generator = function () {
  var i = 0, self = this;
  return function (emit) {
    for (var xs = self.pull().xs_, l = xs.length; i < l;)
      // It's important to do the increment here so that it happens even if we
      // break out of the loop.
      if (emit(xs[i], i++) === false) return false;
  };
};

// Retrieval.
// Technically we just need to implement `get` here. `first` and `last` can, in
// theory, be derived from `each`, `size`, and `get`. However, doing things that
// way is inefficient for arrays because we have direct access to the elements.

methods.get = function (n, fn) {
  var xs = this.pull().xs_;

  // get() -> the current backing array (don't modify this!)
  if (n === void 0) return xs;

  // get(n) -> xs[n] or xs[n + length] if n is negative
  if (typeof n === typeof 0 || n instanceof Number)
    if (n === n >> 0)
      // n is an integer; use direct indexing (but wrap if negative)
      return xs[n < 0 ? xs.length + n : n];
    else {
      // n is a float; use interpolation.
      var f  = arguments.length > 1
               ? infuse.fnarg(arguments, 1)
               : function (a, b, x) {return a + (b-a)*x},
          i1 = (n < 0 ? xs.length : 0) + Math.floor(n),
          i2 = i1 + 1,
          x  = n - i1;
      return f(xs[i1], xs[i2], x);
    }

  return this.get_default.apply(this, arguments);
};

methods.first = function (n) {
  var xs = this.get();

  // first() -> the single first element
  if (n === void 0) return xs[0];

  // first(n) -> infuse([x0, x1, ..., xn-1])
  if (typeof n === typeof 0 || n instanceof Number)
    return infuse.array(xs.slice(0, n < 0 ? xs.length + n : n));

  // first(f) -> the first element that satisfies f, or null
  var f = infuse.fn.apply(this, arguments);
  for (var i = 0, l = xs.length; i < l; ++i)
    if (f(xs[i], i)) return xs[i];
  return null;
};

methods.last = function (n) {
  var xs = this.get(),
      xl = xs.length;

  // last() -> the single last element
  if (n === void 0) return xs[xl - 1];

  // last(n) -> infuse([xn, xn+1, ..., xl-1])
  if (typeof n === typeof 0 || n instanceof Number)
    // Check for n == 0 to save an array copy if at all possible
    return infuse.array(n === 0 ? xs : xs.slice(n < 0 ? xl + n : n));

  // last(f) -> the last element that satisfies f, or null
  var f = infuse.fn.apply(this, arguments);
  for (var i = xl - 1; i >= 0; ++i)
    if (f(xs[i], i)) return xs[i];
  return null;
};

});     // end infuse.type('array')

// Array promotion.
// This hook allows you to say `infuse([1, 2, 3])` and get back an `infuse.array`
// object.

infuse.alternatives.push(
  {accepts:   function (x) {return x instanceof Array},
   construct: function (x) {return infuse.array(x)}});

});

// Generated by SDoc
// Infuse tails | Spencer Tipping
// Licensed under the terms of the MIT source code license

// Infuse tails.
// A tail is an array that contains the last N items of another collection. It
// uses a circular buffer to pull each update in constant time, eagerly shifting
// back into a regular array when you call `get()` with no arguments.

infuse.extend(function (infuse) {
infuse.type('tail', function (tail, methods) {

infuse.mixins.pull(methods);

// Tail state.
// A tail is backed by a Javascript array. We also store the current "zero index",
// which shifts as we add new elements. Tails don't always need to be derivative
// objects, but that's generally where they come from.

methods.initialize = function (size, generator, base) {
  this.xs_        = [],
  this.size_      = size,
  this.zero_      = 0,
  this.base_      = base,
  this.generator_ = generator,
  this.version_   = -1,
  this.pull();
};

methods.size = function () {return this.pull().xs_.length};

methods.push_ = function (v, k) {
  var z = this.zero_++;
  this.xs_[z % this.size_] = v;
  return this;
};

// Derivatives.
// Nothing particularly interesting here. Derivatives inherit the parent's size.

methods.derivative = function (generator) {
  var f = infuse.fn.apply(this, arguments);
  return infuse.tail(this.size_, f, this);
};

// Traversal.
// This is kind of interesting because we want to fully update anyone following a
// tail. Specifically, if someone is frequently pulling updates, they should see a
// continuous array; and if they're sporadically pulling updates, they should see
// as much as we can give them. This turns out to be really easy: we just use our
// zero counter as an array index and behave as if we were an array.

methods.generator = function () {
  var i = 0, self = this;
  return function (emit) {
    var l = self.zero_, xs = self.pull().xs_, m = xs.length;
    i = Math.max(i, l - m);
    for (; i < l;)
      if (emit(xs[i % m], i++) === false) return false;
  };
};

// Retrieval.
// We behave exactly like an array here, except that when interpolating we wrap
// around the end.

methods.get = function (n, fn) {
  var xs = this.pull().xs_,
      l  = xs.length,
      z  = this.zero_;

  // get() -> an eager slice
  if (n === void 0)
    return xs.slice(z % l).concat(xs.slice(0, z % l));

  // get(n) -> xs[n] or xs[n + length] if n is negative
  if (typeof n === typeof 0 || n instanceof Number)
    if (n === n >> 0)
      return xs[(n + l + z) % l];
    else {
      // circular interpolation
      var f  = arguments.length > 1
               ? infuse.fnarg(arguments, 1)
               : function (a, b, x) {return a + (b-a)*x},
          i1 = Math.floor(n + l + z) % l,
          i2 = (i1 + 1) % l,
          x  = n - i1;
      return f(xs[i1], xs[i2], x);
    }

  return this.get_default.apply(this, arguments);
};

});
});

// Generated by SDoc
// Infuse objects | Spencer Tipping
// Licensed under the terms of the MIT source code license

// Infuse objects.
// Like Infuse arrays, objects can be constructed either by wrapping an existing
// object or by specifying a generator function. If you specify a generator, the
// object's value (as returned by `get`, etc) will be updated as new elements
// become available.

// Infuse objects are not considered to be ordered unless you call `keys` or
// `values`. Each of these methods takes a sorted snapshot of the key list to
// guarantee traversal order; so you could request `keys` and `values` and know
// that `k[0]` corresponded to `v[0]`, for instance.

infuse.extend(function (infuse) {
infuse.type('object', function (object, methods) {

// Use pull-propagation updating
infuse.mixins.pull(methods);

// Object state.
// Like an Infuse array, an object has a backing which may be externally
// allocated, and for internally-allocated backings it also has a generator and a
// base.

methods.initialize = function (o_or_f, base) {
  if (o_or_f instanceof Function)
    this.o_         = {},
    this.base_      = infuse.assert(base,
                        'infuse: attempted to construct a derivative '
                      + 'object without specifying a base'),
    this.generator_ = o_or_f,
    this.version_   = -1,
    this.journal_   = infuse.heapmap(),
    this.pull();
  else
    this.o_         = o_or_f,
    this.base_      = null,
    this.generator_ = null,
    this.version_   = 1,
    this.journal_   = null;
};

// Size is the number of distinct key/value pairs stored in the object. This
// function needs to be amortized O(1), so we use the journal to tell us how many
// items we have.

methods.size = function () {return this.pull().journal().size()};

methods.push_ = function (v, k) {
  var o = this.o_;
  o[k] = v;
  this.journal().push(this.version_, k);
  return this;
};

// Derivatives.
// Objects can have derivatives just like arrays can, but the behavior is
// different. An object derivative means "the object will gain new key/value
// mappings in the future", much as an array derivative means "the array will grow
// in the future". So it's a partial journal of changes that will be made to the
// object.

// The main difference between the two is the degree of assumption about
// immutability. Arrays are only allowed to grow; we assume that elements already
// in the array won't change. Objects, on the other hand, might receive value
// updates for existing keys; a common case of this is when you're indexing
// something. This means that a simple array journal has the potential to be
// arbitrarily larger than the object it represents (since it's storing each
// intermediate change).

// As a result, we don't keep the journal this way. Instead, we just use an object
// that maps each key to the last version at which it was modified. Each generator
// can then search this object and apply updates. This makes searching O(n) when
// the object has been updated, O(1) otherwise.

methods.derivative = function (generator, version_base) {
  var f = infuse.fn.apply(this, arguments);
  return infuse.object(f, version_base || this);
};

methods.journal = function () {
  var j = this.journal_;
  if (!j) {
    var o = this.o_,
        v = this.version_;

    // Update all keys to the current version.
    j = this.journal_ = infuse.heapmap();
    for (var k in o)
      if (Object.prototype.hasOwnProperty.call(o, k))
        j.push(v, k);
  }
  return j;
};

// Traversal.
// This is tricky. We need to go through the object's keys in the right order, but
// we can't use the `keys` function to do it because `keys` is defined in terms of
// `generator`. Instead, we maintain a maxheap of key -> version and use that to
// pull changes.

// Heap generators aren't the same as generators for other objects; see
// `infuse.heapmap` for details.

methods.generator = function () {
  var journal_generator = this.journal().generator(),
      o                 = this.o_;
  return function (emit) {
    // The version generator passes the version as 'v' and the key as 'k'; we
    // just need to translate that into our value for the key.
    return journal_generator(function (v, k) {return emit(o[k], k)});
  };
};

// Retrieval.
// Objects don't support `first` or `last`, but they do support `get`, which takes
// a string or array of strings.

methods.get = function (k) {
  var o = this.pull().o_;

  // get() -> the current backing object (don't modify this!)
  if (k === void 0) return o;

  // get(k) -> o[k]
  if (typeof k === typeof '' || k instanceof String) return o[k];

  return this.get_default.apply(this, arguments);
};


});

// Object promotion.
// Detecting a vanilla object turns out to be tricky. We can't do the obvious `x
// instanceof Object` because everything is an instance of `Object`. Long story
// short, we have to rely on `Object.prototype.toString` to tell us.

var obj_tos = Object.prototype.toString.call({});
infuse.alternatives.push(
  {accepts:   function (x) {return Object.prototype.toString.call(x) === obj_tos
                                && !(x instanceof infuse)},
   construct: function (x) {return infuse.object(x)}});

});

// Generated by SDoc
// Infuse multiobjects | Spencer Tipping
// Licensed under the terms of the MIT source code license

// Infuse multi-objects.
// These are just like Infuse objects, but they support multiple values for a
// given key.

infuse.extend(function (infuse) {
infuse.type('multiobject', function (multiobject, methods) {

// Use pull-propagation updating
infuse.mixins.pull(methods);

// Multiobject state.
// Like objects, multiobjects use heapmaps to manage versioning. Unlike objects,
// converting an existing object to a multiobject requires linear time and space.

methods.initialize = function (o_or_f, base) {
  this.o_       = {};
  this.size_    = 0;
  this.journal_ = infuse.heapmap();

  if (o_or_f instanceof Function)
    this.version_   = -1,
    this.generator_ = o_or_f,
    this.base_      = infuse.assert(base,
      'infuse: attempted to create a derivative multiobject without '
    + 'specifying a base'),
    this.pull();
  else {
    this.version_ = 0;
    this.generator_ = null,
    this.base_      = null;
    if (o_or_f)
      for (var k in o_or_f)
        if (Object.prototype.hasOwnProperty.call(o_or_f, k))
          this.push(o_or_f[k], k);
  }
};

// Size is the number of key/value pairs stored, with the provision that multiple
// values per key count independently. So {foo: 2, foo: 3} has size 2.

methods.size = function () {return this.pull().size_};

methods.push_ = function (v, k) {
  var o = this.o_;

  // Even though all values we assign are truthy, it's still important to make
  // this distinction. Otherwise push_(x, 'toString') would cause a runtime
  // error.
  if (Object.prototype.hasOwnProperty.call(o, k)) o[k].push(v);
  else                                            o[k] = infuse.array([v]);

  this.journal().push(this.version_, k);
  ++this.size_;
  return this;
};

// Derivatives.
// Objects can have derivatives just like arrays can, but the behavior is
// different. An object derivative means "the object will gain new key/value
// mappings in the future", much as an array derivative means "the array will grow
// in the future". So it's a partial journal of changes that will be made to the
// object.

// The main difference between the two is the degree of assumption about
// immutability. Arrays are only allowed to grow; we assume that elements already
// in the array won't change. Objects, on the other hand, might receive value
// updates for existing keys; a common case of this is when you're indexing
// something. This means that a simple array journal has the potential to be
// arbitrarily larger than the object it represents (since it's storing each
// intermediate change).

// As a result, we don't keep the journal this way. Instead, we just use an object
// that maps each key to the last version at which it was modified. Each generator
// can then search this object and apply updates. This makes searching O(n) when
// the object has been updated, O(1) otherwise.

methods.derivative = function (generator, version_base) {
  var f = infuse.fn.apply(this, arguments);
  return infuse.multiobject(f, version_base || this);
};

// Traversal.
// This works like the one for `infuse.object`, but emits a separate key/value
// pair for each value mapped by a key.

methods.generator = function () {
  var journal_generator = this.journal().generator(),
      value_generators  = {},
      o                 = this.o_;
  return function (emit, id) {
    return journal_generator(function (v, k) {
      if (!Object.prototype.hasOwnProperty.call(value_generators, k))
        value_generators[k] = o[k].generator();
      value_generators[k](function (v) {return emit(v, k)}, id);
    });
  };
};

// Retrieval.
// The `get` method returns an Infuse array of values for any existing key. You
// can construct derivatives of any such array, and those derivatives will be
// updated as more values are added to that key.

methods.get = function (k) {
  var o = this.pull().o_;

  // get() -> o (don't modify this!)
  if (k === void 0) return o;

  // get(k) -> o[k] (an Infuse array of values, or undefined)
  if (typeof k === typeof '' || k instanceof String) return o[k];

  return this.get_default.apply(this, arguments);
};

});
});

// Generated by SDoc
// Infuse futures | Spencer Tipping
// Licensed under the terms of the MIT source code license

// Introduction.
// A future is a container for a value that will become available later on,
// generally by an asynchronous callback. Futures represent callbacks that have
// not yet been invoked, allowing you to transform the values they will receive or
// otherwise manipulate them as objects.

// Things you can do trivially with futures that are more difficult with just
// callbacks include having an indefinite number of listeners for the result and
// combining N pending results into a single object. Futures are also useful for
// chaining asynchronous computations, but callbacks don't make this particularly
// difficult to begin with.

infuse.extend(function (infuse) {
infuse.type('future', function (future, methods) {

infuse.mixins.push(methods);

// Future state.
// Each future contains a key and a result; the key contextualizes the value and
// is emitted from generators when the value is delivered. Futures have two
// states, undelivered and delivered, and the only transition that happens is from
// undelivered to delivered. So for most purposes they are immutable, and they
// converge to immutable objects. (If you don't want this convergence, you should
// use a signal instead.)

// Because we have this immutability, we can unlink all derivatives once the state
// is finalized.

methods.initialize = function (generator, base) {
  this.listeners_ = {};         // null once the future is decided
  this.bases_     = {};         // null once the future is decided
  this.value_     = null;
  this.key_       = null;
  this.generator_ = null;       // generated on demand

  if (generator) {
    infuse.assert(base,
      'infuse: attempted to construct a derivative future without specifying '
    + 'a base');

    var self = this;
    generator(function (v, k) {return self.push(v, k)}, this.id());
    this.bases_[base.id()] = base;
  }
};

methods.size = function () {return +!this.listeners_};
methods.key  = function () {return this.key_};

// Derivatives.
// Future derivatives are push-notified, not pull-notified, so they work
// differently. We create the derivative and doubly-link it to the base for
// reasons I'll explain in more detail later. At that point we don't need to do
// anything else until we get a value through `push`.

methods.derivative = function (generator, version_base) {
  var f = infuse.fn.apply(this, arguments);
  return infuse.future(f, version_base || this);
};

// Future generators support ID-less emit function registrations. Signals don't
// because a signal will hold onto such a function indefinitely, but futures let
// go of the functions once they are decided, so the scope of the space leak is
// less egregious. It's still a better idea to use `on` or `once` to get a
// singleton future that you use for the callback; that way you can free both by
// calling `detach`.

methods.generator = function () {
  var g = this.generator_;
  if (!g) {
    var self = this;
    g = this.generator_ = function (emit, id) {
      var ls = self.listeners_;
      if (ls) ls[id || infuse.gen_id()] = emit;
      else    return emit(self.value_, self.key_);
    };
  }
  return g;
};

methods.push = function (v, k) {
  infuse.assert(this.listeners_,
    'infuse: attempted to push to an already-decided future');

  // Alert listeners...
  var ls = this.listeners_;
  for (var id in ls)
    if (Object.prototype.hasOwnProperty.call(ls, id))
      ls[id](v, k);

  this.detach();
  this.listeners_ = null;       // ... and then free them; we are now immutable
  this.value_     = v;
  this.key_       = k;
  return this;
};

// Retrieval.
// Futures are modeled sort of like objects with a single key/value after they're
// decided, and no existence at all before they're decided.

methods.get = function (k) {
  // get() -> v if decided, null if undecided
  if (k === void 0) return this.value_;

  // get(k) -> v if decided and k === key, otherwise null
  if (typeof k === typeof '' || k instanceof String)
    if (k === this.key_) return this.value_;
    else                 return null;

  return this.get_default.apply(this, arguments);
};

// Callback interface.
// You can use a future to invoke a callback, and you can also create a callback
// that will trigger the future when you invoke it. Each of these use cases ties a
// key to the callback, which is useful for things like error processing. See the
// future tests for examples.

methods.on = function (keygate, callback, id) {
  keygate = infuse.keygate(keygate);

  // on(keygate) -> signal
  if (!callback) {
    var g = this.generator();
    return infuse.signal(function (emit, id) {
      g(function (v, k) {if (keygate(k)) return emit(v, k)}, id);
    }, this);
  }

  // on(keygate, callback) -> this
  this.generator()(function (v, k) {if (keygate(k)) callback(v, k)},
                   id || infuse.gen_id());
  return this;
};

// Futures can be resolved at most once, so these methods do the same thing. (But
// this is not the case for signals.) Note that it is not a good idea for `once()`
// to optimize the no-keygate case, for two reasons. First, the user can change
// the behavior of an unspecified (undefined) keygate; and second, the result
// should always be different from the receiver so that calling `detach` on it
// won't disrupt the receiver's derivative status.

methods.once = function (keygate, callback, id) {
  keygate = infuse.keygate(keygate);

  // once(keygate) -> future
  if (!callback) {
    var g = this.generator();
    return this.derivative(function (emit, id) {
      g(function (v, k) {if (keygate(k)) return emit(v, k)}, id);
    });
  }

  // once(keygate, callback) -> this
  return this.on(keygate, callback, id);
};

methods.trigger = function (k) {
  var self = this;
  return function (v) {self.push(v, k)};
};

});
});

// Generated by SDoc
// Infuse signals | Spencer Tipping
// Licensed under the terms of the MIT source code license

// Introduction.
// A signal is just like a future, but it can be resolved asynchronously multiple
// times. As a result, it retains its listener list, which means that derivatives
// are live until the base is freed.

infuse.extend(function (infuse) {
infuse.type('signal', function (signal, methods) {

infuse.mixins.push(methods);

// Signal state.
// Signals retain the last key/value they took on, and they also maintain the list
// of listeners indefinitely.

methods.initialize = function (generator, base) {
  this.listeners_ = {};         // stored until explicitly detached
  this.bases_     = {};         // stored until explicitly detached
  this.value_     = null;
  this.key_       = null;
  this.generator_ = null;       // generated on demand
  this.size_      = 0;          // number of values processed by the signal

  if (generator) {
    infuse.assert(base,
      'infuse: attempted to construct a derivative signal without specifying '
    + 'a base');

    var self = this;
    generator(function (v, k) {return self.push(v, k)}, this.id());
    this.bases_[base.id()] = base;
  }
};

methods.size = function () {return this.size_};
methods.key  = function () {return this.key_};

// Derivatives.
// Signals are linked back to their "version bases", or the objects that have been
// tasked with keeping them up to date. This makes it possible to call `detach` on
// a derivative future and remove both linkages.

methods.derivative = function (generator, version_base) {
  var f = infuse.fn.apply(this, arguments);
  return infuse.signal(f, version_base || this);
};

methods.generator = function () {
  var g = this.generator_;
  if (!g) {
    var self = this;
    g = this.generator_ = function (emit, id) {
      infuse.assert(id != null,
        'infuse: attempted to construct a push generator without specifying '
      + 'an ID (this may cause space leaks, so it is disallowed)');
      self.listeners_[id] = emit;
    };
  }
  return g;
};

// Order of operations matters inside `push`. We need to increment the version
// before alerting listeners so that listeners can use version deltas to figure
// out which of potentially many signals emitted a value.

methods.push = function (v, k) {
  // Update state to reflect the change...
  this.value_ = v;
  this.key_   = k;
  ++this.size_;

  // ... and alert listeners.
  var ls = this.listeners_;
  for (var id in ls)
    if (Object.prototype.hasOwnProperty.call(ls, id))
      ls[id](v, k);

  return this;
};

// Retrieval.
// Signals behave just like futures that change if decided again. They always
// consist of a single key/value mapping, and sometimes the key is empty or null.

methods.get = function (k) {
  // get() -> v if decided, null if undecided
  if (k === void 0) return this.value_;

  // get(k) -> v if decided and k === key, otherwise null
  if (typeof k === typeof '' || k instanceof String)
    if (k === this.key_) return this.value_;
    else                 return null;

  return this.default_get.apply(this, arguments);
};

// Callback interface.
// You can use a signal to invoke a callback, and you can also create a callback
// that will trigger the signal when you invoke it.

methods.on = function (keygate, callback, id) {
  keygate = infuse.keygate(keygate);

  // on(keygate) -> signal
  if (!callback) {
    var g = this.generator();
    return this.derivative(function (emit, id) {
      g(function (v, k) {if (keygate(k)) return emit(v, k)}, id);
    }, this);
  }

  // on(keygate, callback) -> this
  this.generator()(function (v, k) {if (keygate(k)) callback(v, k)},
                   id || infuse.gen_id());
  return this;
};

// Similar to `on` is `once`, which creates a callback that is invoked only once
// and then removed from the listener list. This can prevent a space leak for
// cases where you need transient anonymous listeners. Invoked without a callback,
// `once` returns a future that is triggered on the receiver's first value.

methods.once = function (keygate, callback, id) {
  id      = id || infuse.gen_id();
  keygate = infuse.keygate(keygate);

  // once(keygate) -> future
  if (!callback) {
    var g = this.generator();
    return infuse.future(function (emit, id) {
      g(function (v, k) {if (keygate(k)) return emit(v, k)}, id);
    }, this);
  }

  // once(keygate, callback) -> this
  var self = this;
  this.generator()(function (v, k) {
                     if (keygate(k)) {
                       delete self.listeners_[id];
                       callback(v, k);
                     }
                   }, id);
  return this;
};

methods.trigger = function (k) {
  var self = this;
  return function (v) {self.push(v, k)};
};

});
});

// Generated by SDoc
// Infuse edges | Spencer Tipping
// Licensed under the terms of the MIT source code license

// Infuse edges.
// An edge connects two signals, optionally transforming values as they travel
// between them. The result is that every update to either signal will be
// propagated to the other. Edges are undirected. Circular graphs will cause
// stack-overflow errors, which isn't too big a deal considering what edges are
// used for.

// You can connect an edge to a synchronous object, but no changes will be pulled
// from that object (since it never emits things asynchronously). You can,
// however, invoke `pull` on the edge to look for changes on the synchronous
// endpoint.

// You don't generally construct edges directly; the `to` method is the simplest
// way to link objects. (See the [edge tests](edge.md) for details.)

infuse.extend(function (infuse) {
infuse.type('edge', function (edge, methods) {

// Edge state.
// Edges maintain references to the objects they are connecting and the most
// recent versions of those objects.

methods.initialize = function (a, b, fab, fba) {
  this.a_       = a;
  this.b_       = b;
  this.ga_      = a.generator();
  this.gb_      = b.generator();
  this.va_      = a.version();
  this.vb_      = b.version();
  this.sig_     = infuse.signal();
  this.gate_    = infuse.signal();
  this.keygate_ = this.gate_.map(infuse.keygate);

  this.gate_.push(null);

  fab = infuse.fn(fab);
  fba = infuse.fn(fba);

  var self = this;
  this.from_a_ = function (v, k) {return self.push(fab(v, k), k)};
  this.from_b_ = function (v, k) {return self.push(fba(v, k), k)};

  this.ga_(this.from_a_, this.id());
  this.gb_(this.from_b_, this.id());
};

methods.size    = function () {return this.sig_.size()};
methods.version = function () {return this.sig_.version()};

// Gating.
// You can specify which kinds of keys propagate along the edge in two ways. The
// simplest way is to call `keygate()`. If you invoke it with no arguments, it
// will return the current compiled keygate.

methods.keygate = function (gate) {
  if (arguments.length) {
    this.gate_.push(gate);
    return this;
  } else
    return this.keygate_.get();
};

// The other way is to push a value into the `gate` signal. This is useful when
// you want to use edges to manage the keygates of other edges.

methods.gate = function () {return this.gate_};

// Detachment.
// Detaching an edge means removing its connection to both endpoints. You can't
// have an edge with just one connection. You can't reattach an edge once you have
// detached it.

methods.detach = function () {
  this.a_.detach_derivative(this);
  this.b_.detach_derivative(this);
  this.a_ = this.b_ = null;
  return this;
};

methods.detach_derivative = function (derivative) {
  this.sig_.detach_derivative(derivative);
  return this;
};

// Derivatives.
// Edges derive signals that are triggered whenever a value travels along the
// edge.

methods.derivative = function (generator, version_base) {
  return this.sig_.derivative(generator, version_base);
};

methods.generator = function () {
  return this.sig_.generator();
};

// Propagation.
// This is tricky because each edge operates independently of other edges. As a
// result, edges can't coordinate to detect infinite loops. This means that all
// infinite loop detection must be done by making local observations about the
// endpoints.

// The key invariant here is that we're allowed to push to any endpoint we're up
// to date with. So each edge becomes one-directional and idempotent within the
// context of an update operation.

// If the value you send through an edge is a future or signal, the edge waits to
// propagate the change until the future is resolved.

methods.push = function (v, k) {
  var a = this.a_,
      b = this.b_;

  infuse.assert(a && b,
    'infuse: cannot push to an edge with undefined endpoints (this '
  + 'happens if you call push() on an edge after detaching it)');

  if (!this.keygate_.get()(k))
    return this;

  var self = this;
  infuse.on(v, null, function (v) {
    var va = a.version(),
        vb = b.version(),
        sa = self.va_,
        sb = self.vb_;

    if (sa < va && sb >= vb)
      self.sig_.push(v, k),
      b.push(v, k),                             // commit value to b
      self.gb_(self.from_b_, self.id()),        // pull updates
      self.vb_ = sb = b.version(),              // catch up to b
      self.va_ = sa = va;                       // enable propagation back to a

    if (sb < vb && sa >= va)
      self.sig_.push(v, k),
      a.push(v, k),                             // commit value to a
      self.ga_(self.from_a_, self.id()),        // pull updates
      self.va_ = sa = a.version(),              // catch up to a
      self.vb_ = sb = vb;                       // enable propagation back to b
  });

  return this;
};

// You can connect an edge to one or more synchronous objects. If you do, you'll
// need to manually call `pull` to get the changes to propagate. Note that if both
// objects have diverged, **calling `pull` will do nothing**! You can check for
// this state using the `is_divergent` method, and you can choose either endpoint
// using `choose`.

methods.is_divergent = function () {
  return this.a_.version() > this.va_
      && this.b_.version() > this.vb_;
};

// Choosing a value doesn't activate any propagation, it just makes it so that the
// edge is able to push to the other endpoint. If the endpoints are synchronous,
// you'll want to invoke `pull` after `choose`.

methods.choose = function (x, force) {
  if (this.is_divergent() || force)
    if      (x === this.a_ || x === true)  this.vb_ = this.b_.version();
    else if (x === this.b_ || x === false) this.va_ = this.a_.version();
    else throw new Error('infuse: attempted to choose() a nonexistent '
                       + 'endpoint');
  return this;
};

methods.pull = function () {
  if (this.va_ < this.a_.pull().version()) this.ga_(this.from_a_, this.id());
  if (this.vb_ < this.b_.pull().version()) this.gb_(this.from_b_, this.id());
  return this;
};

});
});

// Generated by SDoc
// Infuse methods | Spencer Tipping
// Licensed under the terms of the MIT source code license

// Introduction.
// This module defines most of the methods that are common to all Infuse types.
// Each of the methods defined here is based on implementations of `derivative`
// and `generator`.

infuse.extend(function (infuse, methods) {

methods.tap = function (fn) {
  infuse.fn.apply(this, arguments)(this);
  return this;
};

// Instance identification.
// For various reasons it becomes useful to have an object-key reference for any
// Infuse object. This value is used as the second argument to functions given to
// `get`.

methods.id = function () {
  var id = this.id_;
  if (!id) id = this.id_ = infuse.gen_id();
  return id;
};

// Key/value querying.
// These are simply array objects based on the values emitted by the generator.

methods.keys = function () {
  var g = this.generator();
  return infuse.array(function (emit, id) {
    g(function (v, k) {return emit(k, k)}, id);
  }, this);
};

// This just converts the object to an Infuse array. It's important that this
// method returns a distinct object; otherwise things like detach() might be sent
// to the wrong receiver.

methods.values = function () {
  var g = this.generator();
  return infuse.array(g, this);
};

methods.inverse = function () {
  var g = this.generator();
  return this.derivative(function (emit, id) {
    g(function (v, k) {return emit(k, v)}, id);
  });
};

// Transcoding.
// All Infuse objects are expressed in terms of generators that emit (value, key)
// tuples. This means that you can easily convert between types. The simplest way
// to do it is to use `into`, which has two main modes of operation. If you say
// something like `xs.into(infuse.array)`, you'll get a derivative array. If you
// use it with an existing Infuse object, or something that can be promoted into
// an Infuse object, you'll get that object back with extra elements.

// You can't use `into` to modify a derivative; doing so will result in an error.

methods.into = function (xs_or_constructor) {
  if (typeof xs_or_constructor === typeof infuse) {     // constructor function?
    var args = infuse.slice(arguments, 1);              // get extra args
    args.push(this.generator());                        // set up derivative
    args.push(this);
    return xs_or_constructor.apply(infuse, args);
  }

  if (xs_or_constructor instanceof infuse) {            // wrapped already?
    this.generator()(function (v, k) {xs_or_constructor.push(v, k)},
                     xs_or_constructor.id());
    return xs_or_constructor;
  }

  // A primitive type. Promote it, push values in, and then convert back to a
  // primitive.
  return this.into(infuse.apply(this, arguments)).get();
};

// Get shorthands.
// Sometimes you have multiple nested Infuse objects (particularly with futures),
// and you want to get to a primitive. You can do this with `fget`:

methods.fget = function () {
  var result = this.get.apply(this, arguments);
  while (result instanceof infuse) result = result.get();
  return result;
};

// You can also use `mget` to cascade multiple `get` arguments:

methods.mget = function () {
  var result = this;
  for (var i = 0, l = arguments.length; i < l; ++i)
    result = result.get(arguments[i]);
  return result;
};

// Pairing.
// Any Infuse object can be encoded as an array of `[value, key]` pairs.
// Similarly, we can construct an Infuse collection of many types from such an
// array. Note that while `pairs` returns a true derivative, `unpair` does not and
// in general can't: it isn't always possible to attach an Infuse collection to an
// arbitrary source. For cases when it is possible, you should use the `into`
// method.

methods.pairs = function () {
  var g = this.generator();
  return infuse.array(function (emit, id) {
    g(function (v, k) {return emit([v, k])}, id);
  }, this);
};

// You can use `unpair` to transcode objects: `infuse({}).unpair(xs.pairs())`.
// This form is useful when the receiver, which receives elements, doesn't have a
// fixed type. (Though it's faster just to use `into` unless you're transforming
// the values.)

methods.unpair = function (pairs) {
  var g    = infuse(pairs).generator(),
      self = this;
  g(function (pair) {self.push(pair[0], pair[1])}, this.id());
  return this;
};

// Generator combination.
// Methods to combine multiple objects. Combined objects inherit changes from
// multiple bases. `plus` and `zero` are closed under the receiver's type.

methods.plus = function () {
  var f = infuse.funnel([this].concat(infuse.toa(arguments)));
  return this.derivative(f.generator(), f);
};

methods.zero = function () {
  return this.derivative(function () {}, this).detach();
};

// Traversal.
// The generator order can be used to define `each`; we just throw the generator
// away at the end. It is generally an error to invoke `each` on an asynchronous
// collection; you should use `on` or `once` instead.

methods.each = function (fn) {
  var f = infuse.fn.apply(this, arguments);
  this.generator()(f);
  return this;
};

// Sequence transformations.
// The usual suspects: `map`, `flatmap`, etc. These apply to all data types based
// on the semantics of `derivative` and `generator`.

methods.map = function (fn) {
  var f = infuse.fn.apply(this, arguments),
      g = this.generator();
  return this.derivative(function (emit, id) {
    g(function (v, k) {return emit(f(v, k), k)}, id);
  });
};

methods.kmap = function (fn) {
  var f = infuse.fn.apply(this, arguments),
      g = this.generator();
  return this.derivative(function (emit, id) {
    g(function (v, k) {return emit(v, f(k, v))}, id);
  });
};

methods.flatmap = function (fn) {
  var f = infuse.fn.apply(this, arguments),
      g = this.generator();
  return this.derivative(function (emit, id) {
    g(function (v, k) {var y = f(v, k);
                       return y && infuse(y).generator()(emit, id)}, id);
  });
};

methods.filter = function (fn) {
  var f = infuse.fn.apply(this, arguments),
      g = this.generator();
  return this.derivative(function (emit, id) {
    g(function (v, k) {if (f(v, k)) return emit(v, k)}, id);
  });
};

methods.mapfilter = function (fn) {
  var f = infuse.fn.apply(this, arguments),
      g = this.generator();
  return this.derivative(function (emit, id) {
    g(function (v, k) {
      var y = f(v, k);
      if (y) return emit(y, k);
    }, id);
  });
};

// For convenience:

methods.join = function (sep) {
  return this.values().get().join(sep);
};

// Default function promotion.
// Infuse objects can be promoted into structure-preserving functions. For
// example, `{foo: f}` becomes `function (x) {return {foo: f(x)}}`. Like all
// Infuse objects, the function result is an automatically-updating derivative,
// and it generates derivative Infuse collections.

methods.fn = function () {
  var mapped = this.map(function (v, k) {return infuse.fn(v)});
  return function () {
    var self = this, args = arguments;
    return mapped.map(function (v, k) {return v.apply(self, args)});
  };
};

// Default `get` implementation.
// This is what individual Infuse collections use when no collection-specific
// alternatives match. It's written so that:

// | infuse([1, 2, 3]).get([2, 1])         -> infuse([3, 2])
//   infuse([1, 2, 3]).get({foo: 0})       -> infuse({foo: 1})

// It also has desirable properties for working with asynchronous collections.

methods.get_default = function (x) {
  // get(infusable) -> infuse.map(x -> y -> y.get(x)).fn()(this, this.id())
  if (infuse.accepts(x)) {
    var self = this;
    return infuse.fn(infuse(x).map(function (x) {
      return function (y) {return y.get(x)};
    }))(this, this.id());
  }

  // get(...) -> fn(...)(this, this.id())
  return infuse.fn.apply(this, arguments)(this, this.id());
};

// Lazy sorting.
// You can sort the values in any Infuse object and the result will be updated
// lazily. Generators that traverse sorted objects will remember the last value
// and will pick up at that point; so even if the Infuse object receives updates
// earlier on, all generators will see the most up-to-date fully-ordered view of
// data possible.

// Sorting functions return in constant time and the derivative collections are
// lazily sorted in O(n log n + r(n + k log n)) time, where r is the number of
// generator re-entrances, k is the number of realized elements, and n is the size
// of the receiver.

// These functions have a fairly large constant-factor overhead. You're probably
// better off using Javascript's native `sort()` method if performance is
// important. (Actually, don't use Infuse at all if you're counting microseconds;
// it's fast, but indirection is indirection.)

// Note that multi-objects cannot be sorted meaningfully; you'll get a multiobject
// with a different structure. This problem arises because the key->value
// transform of a multiobject is not a well-defined function.

// Also note that this `sort` function is unstable, so it takes an ordering
// function that returns `true` if its first argument is less than the second,
// `false` otherwise. You can get such a function from a comparator by using
// `infuse.comparator_to_ordering`.

methods.sort = function (fn) {
  var f    = fn && infuse.fn.apply(this, arguments),
      h    = infuse.heapmap(f, this.generator(), this),
      g    = h.generator(),
      self = this;
  return this.derivative(function (emit, id) {
    g(function (v, k) {return emit(self.get(k), k)}, id);
  }, h);
};

// Sort-by allocates a backing collection of transformed values, sorts that, and
// remaps the keys back into the original collection's space. This means that your
// base collection must support `get` over its keyspace.

methods.sortby = function (fn) {
  var f    = infuse.fn.apply(this, arguments),
      sg   = this.generator(),
      h    = infuse.heapmap(null, function (emit, id) {
               sg(function (v, k) {return emit(f(v, k), k)}, id);
             }, this),
      g    = h.generator(),
      self = this;
  return this.derivative(function (emit, id) {
    g(function (v, k) {return emit(self.get(k), k)}, id);
  }, h);
};

// The `uniq` method returns distinct values **from a sorted collection**. Because
// Infuse collections are potentially infinite (or at least, they have indefinite
// size), it doesn't try to maintain a set of all objects seen. As a result, it
// operates in constant space and per-element time, holding only the last-seen
// value. If given a function, values for which that function returns unique
// values are emitted.

methods.uniq = function (fn) {
  var f    = fn ? infuse.fn.apply(this, arguments)
                : function (x) {return x},
      g    = this.generator(),
      last = {};                // {} !== everything
  return this.derivative(function (emit, id) {
    g(function (v, k) {
      if (last !== (last = f(v))) return emit(v, k);
    }, id);
  });
};

// Reductions.
// Most systems treat reductions as being generic across lazy and strict
// sequences. Infuse can't do this, however, because some sequences are push-lazy
// (and besides, Javascript isn't idiomatically lazy enough to have pull-lazy
// sequences and lazy right-folds anyway).

// As a result, we implement two forms of `reduce`. The eager one, `reduce`,
// returns a final answer that is not wrapped in an Infuse object, while the lazy
// one, `reductions`, returns a result whose value may be updated as the
// underlying sequence gains values. You're allowed to call `reduce` on a future
// or signal, but it probably won't do anything very useful.

// However, you can invoke `f.reductions(0, '_1 + _2')` to get a future that is
// initially undelivered and then is delivered with the receiver. (Reducing a
// signal is a little more interesting, since signal reductions continue to update
// and accumulate.)

// More intuitively, a signal is like a lazy sequence whose index is time.
// Obviously you can't faithfully reduce it in a strict way, since it doesn't have
// any kind of "last" value. So if you want to fold it up, the best you can do is
// observe it at each change point, and to do that you ask for all of its
// reductions.

// If you're only interested in the last value of `reductions`, such as if you
// just want a running total, you can use `reduction` to avoid consing up an
// array.

methods.reductions = function (into, fn) {
  var f = infuse.fnarg(arguments, 1),
      g = this.generator();
  return this.derivative(function (emit, id) {
    g(function (v, k) {return emit(into = f(into, v, k), k)}, id);
  });
};

methods.reduction = function (into, fn) {
  var f = infuse.fnarg(arguments, 1),
      g = this.generator();
  return infuse.cell(function (emit, id) {
    g(function (v, k) {return emit(into = f(into, v, k), k)}, id);
  }, this);
};

methods.reduce = function (into, fn) {
  var f = infuse.fnarg(arguments, 1);
  this.each(function (v, k) {into = f(into, v, k)});
  return into;
};

// Indexing.
// You can group or index a sequence's values into an object. The index function
// should take an element (and optionally its key, position, whatever), and return
// a string for the index.

methods.index = function (fn) {
  var f = infuse.fn.apply(this, arguments),
      g = this.generator();
  return infuse.object(function (emit, id) {
    g(function (v, k) {return emit(v, f(v, k))}, id);
  }, this);
};

methods.group = function (fn) {
  var f = infuse.fn.apply(this, arguments),
      g = this.generator();
  return infuse.multiobject(function (emit, id) {
    g(function (v, k) {return emit(v, f(v, k))}, id);
  }, this);
};

// Tail.
// Just like the UNIX `tail -f`. It keeps a circular buffer of items and supports
// derivatives and updates just like other collections.

methods.tail = function (n) {
  var g = this.generator();
  return infuse.tail(n, g, this);
};

// Edges.
// You can make an edge between any two objects by using the `to` function. You're
// required to specify an object to connect the receiver to, and you can
// optionally specify two functions, one to transform values in each direction.
// `ifn` is not required to be the inverse of `fn`, but it probably should be.

// Edges are legal between synchronous collections; in that case, it is up to you
// to call `pull` on the edge to manually propagate changes in either direction.
// See the [edge documentation](edge.md) and [source](edge-src.md) for more
// details about this.

methods.to = function (o, fn, ifn) {
  return infuse.edge(this, o, fn, ifn);
};

});

// Generated by SDoc
