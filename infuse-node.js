// Infuse core | Spencer Tipping
// Licensed under the terms of the MIT source code license

// Introduction.
// All Infuse objects support a large set of core methods. Many of these methods
// are implemented in terms of other, type-specific methods; for example, `each`
// is a type-specific method that is used for `all` and `any`. This file defines
// the global `infuse` function and the mechanism used to define type-specific
// infuse implementations.

(function () {
  var original_infuse = typeof infuse !== typeof void 0 ? infuse : undefined;

  var dispatcher = function (name) {
    var result = function (x) {
      for (var xs = result.alternatives, i = xs.length - 1, t; i >= 0; --i)
        if ((t = xs[i]).accepts.apply(t, arguments))
          return t.construct.apply(t, arguments);
      throw new Error(
        name + '(' + Array.prototype.slice.call(arguments).join(', ')
             + ') is not supported (no alternative accepted the supplied '
             + 'arguments)');
    };

    result.alternatives = [];
    return result;
  };

  var infuse_global = dispatcher('infuse');
  infuse_global.dispatcher = dispatcher;

  infuse_global.hide = function () {
    infuse = original_infuse;
    original_infuse = null;
    delete infuse_global.hide;
    return infuse_global;
  };

  infuse_global.unloaders = [];
  infuse_global.unload = function () {
    for (var xs = infuse_global.unloaders, i = 0, l = xs.length; i < l; ++i)
      xs[i]();
  };

  infuse = infuse_global;
})();

// Bind a local variable so that extend() works even after hiding the global.
(function (infuse) {
  infuse.extend = function (body) {
    return body.call(infuse, infuse, infuse.prototype) || infuse;
  };
})(infuse);

infuse.extend(function (infuse) {

// Infuse function instantiation.
// We don't really advertise this because it isn't generally useful, but you can
// instantiate the global Infuse object as a class to enable prototype
// inheritance. Infuse uses this internally when you define new types.

var as_ctor = {};
infuse.alternatives.push(
  {accepts:   function (x) {return x === as_ctor},
   construct: function ()  {}});

// Methods and type definition.
// All global methods are installed on `infuse.prototype`. Subclasses then inherit
// from `infuse` using the usual Javascript inheritance pattern.

infuse.type = function (name, body) {
  var ctor = infuse[name] = function () {
    if (this.constructor !== ctor) {
      var result = new ctor();
      result.initialize.apply(result, arguments);
      return result;
    }
  };
  (ctor.prototype = new infuse(as_ctor)).constructor = ctor;
  return body.call(ctor, ctor, ctor.prototype) || ctor;
};

infuse.mixins = {};
infuse.mixin = function (name, body) {
  var methods = {};
  body.call(methods, methods);

  return infuse.mixins[name] = function (proto) {
    // Mix methods into proto.
    for (var k in methods)
      if (Object.prototype.hasOwnProperty.call(methods, k))
        proto[k] = methods[k];
    return proto;
  };
};

});

// Generated by SDoc
// Infuse pull-propagation mixin | Spencer Tipping
// Licensed under the terms of the MIT source code license

// Introduction.
// All Infuse collections support some form of derivatives and dynamic updating.
// This mixin assumes the presence of a few instance variables and provides the
// methods required to create linked derivatives. To use this mixin, you need to
// define/maintain the following:

// | this.base_            the source for this derivative collection
//   this.generator_       a generator function that accepts an emitter
//   this.version_         the current version of this object
//   this.push_(v, k)      a function that adds a new element to the object

// Given that, this mixin provides a complete implementation of pull-propagation,
// as well as defining a wrapper `push` method that takes care of version
// updating and derivative checking.

infuse.extend(function (infuse) {
infuse.mixin('pull', function (methods) {

// Trivial accessors.
// We assume the presence of `base_`, `version_`, and `generator_`. Of these,
// `generator_` is kept private because accessing it changes its state.

methods.base    = function () {return this.base_};
methods.version = function () {return this.version_};

// Pull propagation.
// You can pull any collection with a base (it's a nop for independent
// collections). An invariant is that invoking `pull` with no arguments will cause
// the receiver to become up-to-date with the base. As a result, the receiver's
// version will bet set equal to the base's version.

methods.pull = function () {
  var b = this.base_,
      v = b && b.pull().version();

  // Invoking generators is potentially expensive, so only do it if there's a
  // version discrepancy.
  if (v && v > this.version_) {
    // Optimistically pre-increment the version so that any push_ calls made by
    // the generator will see the new version.
    ++this.version_;
    var self = this;
    this.generator_(function (v, k) {self.push_(v, k)}, this.id());
    this.version_ = v;
  }

  return this;
};

methods.push = function (v, k) {
  infuse.assert(!this.base_, 'infuse: attempted to push onto a derivative');
  ++this.version_;
  return this.push_(v, k);
};

// Detaching.
// You can detach any pull-propagated collection from its source to allow the
// source to be garbage-collected. Doing this also enables the collection to be
// modified by using `push`. `detach` does nothing if the collection is already
// detached.

methods.detach = function () {
  if (this.base_) this.base_.detach_derivative(this);
  this.base_ = this.generator_ = null;
  return this;
};

// Do nothing; we don't track derivatives.
methods.detach_derivative = function (derivative) {
  return this;
};

});
});

// Generated by SDoc
// Infuse push-propagation mixin | Spencer Tipping
// Licensed under the terms of the MIT source code license

// Introduction.
// This mixin provides method implementations useful for push-updated objects. The
// assumption is that push updates happen asynchronously, though they could also
// be synchronous in certain cases.

infuse.extend(function (infuse) {
infuse.mixin('push', function (methods) {

// Compatibility.
// It's legal to use a push collection as the basis for a pull collection, and
// this actually happens quite frequently. To make this work, we need to implement
// two methods: `pull` (which does nothing), and `version`. A push-propagated
// object's version is just its size; presumably this is monotonically increasing
// (if not, you should define a different version strategy).

methods.pull    = function () {return this};
methods.version = function () {return this.size() + 1};

// Detachment.
// Push objects are forward-linked, so we need to inform the parent that the
// derivative should be detached. In order to do this, we need to construct a
// unique identifier for each derivative.

methods.detach = function (base) {
  // Two possibilities. If a base is specified, then detach from that one
  // specifically. Otherwise, detach from all bases.
  if (base)
    base.detach_derivative(this),
    delete this.bases_[base.id()];
  else {
    var bs = this.bases_;
    for (var id in bs)
      if (Object.prototype.hasOwnProperty.call(bs, id))
        bs[id].detach_derivative(this),
        delete bs[id];
  }
  return this;
};

methods.detach_derivative = function (derivative) {
  // Free the listener if possible.
  var ls = this.listeners_;
  if (ls) delete ls[derivative.id()];
  return this;
};

});
});

// Generated by SDoc
// Infuse utilities | Spencer Tipping
// Licensed under the terms of the MIT source code license

// Introduction.
// This module defines global functions on the `infuse` global.

infuse.extend(function (infuse) {

var id = 0;
infuse.gen_id = function () {return 'infuse-' + ++id};

infuse.toa   = function (xs)    {return Array.prototype.slice.call(xs)};
infuse.slice = function (xs, n) {return Array.prototype.slice.call(xs, n)};

infuse.fnarg = function (args, i) {
  // Make a function from arguments[i] and beyond. O(n) in the number of
  // arguments, though in most cases the GC overhead probably outweighs the
  // complexity.
  return infuse.fn.apply(this, infuse.slice(args, i));
};

infuse.assert = function (x, message) {
  if (!x) throw new Error(message);
  return x;
};

infuse.assert_equal = function (x, y) {
  infuse.assert(x === y, x + ' != ' + y);
  return x;
};

infuse.msb = function (x) {
  // Index of most-significant bit of x, where msb(1) = 0.
  for (var lower = 0, upper = 64; lower + 1 < upper;) {
    var mid     = lower + upper >>> 1,
        shifted = x >>> mid;
    if (shifted && shifted !== x) lower = mid;
    else                          upper = mid;
  }
  return lower;
};

});

// Generated by SDoc
// Infuse heapmap | Spencer Tipping
// Licensed under the terms of the MIT source code license

// Introduction.
// A fairly trivial minheap-map implementation used by the cache as a priority
// queue. This heap stores objects independently from their priorities, so you can
// update an object's priority dynamically and it will heapify up or down
// accordingly.

// Like other Infuse collections, heap maps support lazy derivatives. Unlike other
// collections, however, heaps are not append-only. This makes lazy derivatives
// interesting, as we might need to update any element at any point.

// To deal with this, a heap generator doesn't follow the same rules that other
// generators do. Instead, its guarantee is that successively emitted elements
// will have increasing heap indexes (so they are descending in the heap). The
// generator tracks the last heap index emitted and emits elements greater than
// that.

// A nice result of doing things this way is that you can (reasonably) efficiently
// use a heap generator to implement an update journal (see `infuse.object` for an
// example).

infuse.extend(function (infuse) {
infuse.type('heapmap', function (heapmap, methods) {

// Enable pull-propagation updating
infuse.mixins.pull(methods);

// Heap state.
// A heap stores the ordering function, which takes two elements and returns true
// if the first should be above the second (so for a minheap, `a < b`). It also
// contains the element set, an internal map that keeps track of where each
// element is stored in the array.

// Heapmaps are maps, so you can't store arbitrary data in them (well, you can I
// guess, but then the map will break). If you want the map functionality, then
// the data you're storing must be a string.

methods.initialize = function (above, generator, base) {
  this.above_     = above ? infuse.fn.apply(this, arguments)
                          : function (a, b) {return a <= b};
  this.xs_        = [null];             // stores heap indexes (values)
  this.keys_      = [null];             // stores entry keys
  this.map_       = {};                 // maps keys to array indexes
  this.base_      = base;
  this.generator_ = generator;

  infuse.assert(!!base === !!generator,
    'infuse: base and generator must be specified together ('
  + 'error constructing heapmap)');
};

methods.size = function () {return this.pull().xs_.length - 1};

// Derivatives.
// Heap maps are interesting because they're mutable, which violates an assumption
// that Infuse makes about viewable collections (i.e. things with derivatives).
// Normally this would disqualify heapmaps from being Infuse collections at all,
// but in this case we can work around it by changing the semantics of appending.
// Rather than considering objects over time, we use heap ordering of objects.
// This logic is explained further in the `generator` method.

methods.derivative = function (generator) {
  var f = infuse.fn.apply(this, arguments);
  return infuse.heapmap(this.above_, f, this);
};

// Traversal.
// Heaps are traversed in heap-sorted order, which means that each generator
// requires an extra O(log n) time to identify the next child. This is a
// data-recursive process: the generator maintains a heap of child entries. Here's
// what is going on:

// |                       5               <- heap root; we start here
//                       /   \
//                     9       8
//                   /  \     /
//                 40    10  9

// The user asks for a generator of the heap. We're required to present them with
// a sorted list of keys, which we do by nondestructively traversing the heap
// downwards:

// |                     c(5)              <- emit 5
//                     /      \
//                   9          8          <- push children onto a heap

// There are two sub-heaps after we emit 5, and in general because of the freedom
// in the heap property there could be O(n) subheaps that we need to worry about.
// We need the minimum of all subheaps. So, like any computer scientist should, we
// allocate another heap to keep track of the subheaps:

// |                    8                  <- the generator's heap; 8 is next
//                     /
//                    9

// Then each generator fetch is just a matter of returning the minimum element of
// its heap and pushing the heap's children.

methods.generator = function () {
  var self = this;

  var limit      = null,                // updated by the generator
      have_limit = false;

  return function (emit) {
    var xs   = self.xs_,
        keys = self.keys_,
        l    = xs.length;

    if (l <= 1) return;                 // nothing to do (yet)

    if (!have_limit)                    // get initial limit if necessary
      limit      = xs[1],
      have_limit = true;

    // First step: check to see whether we have any nodes that satisfy the
    // ceiling property. If not, then we're done.
    var depth   = infuse.msb(l - 1),
        initial = self.initial_ceiling_(limit, depth);

    if (initial === null) return;       // nothing to do (no initial ceiling)

    // We have to rebuild the next-child heap each time the generator is
    // called. Otherwise we might not catch modifications made to the heap
    // between generator calls. Like other generators, we disallow
    // comodification; you must exit the generator by returning false before
    // you modify the collection it's traversing.
    var child_selector = infuse.heapmap(self.above_),
        initial_v      = self.version_;

    // Populate the child selector. We need to fully traverse the ceiling
    // before we know which element to choose next (actually, this isn't quite
    // true if we see something that equals the limit; but coding for
    // referential equality is not really appropriate).
    for (var i = self.initial_ceiling_(limit, depth), x;
         i !== null;
         limit = x, i = self.next_ceiling_(limit, i, depth))
      child_selector.push(x = xs[i], i);

    // Now start emitting stuff. Push the children of each element we pull
    // until there are no children left.
    while (child_selector.size()) {
      var i = +child_selector.pop();
      if (emit(limit = xs[i], keys[i]) === false) return;

      var left = i << 1;
      if (left < l) {
        child_selector.push(xs[left], left);
        var right = left + 1;
        if (right < l) child_selector.push(xs[right], right);
      }
    }
  };
};

// Ceiling generation.
// A ceiling node is defined as an inclusive lower bound for a value. We refer to
// them by indexes within `xs`. The goal is usually to generate all ceilings for a
// given value bound.

// This is used when re-entering a generator. We pass in the minimum (topmost)
// value we're looking for and the index of the heap node we're starting with
// (generally the `initial_ceiling_` for the first call), and `next_ceiling_`
// returns the index of the next node we should look at. If there are no more
// elements, `next_ceiling_` returns `null`.

// The traversal order from this function is left-to-right within the tree
// representation of a heap. This means that there is no ordering among ceilings.

methods.next_ceiling_ = function (v, i, depth) {
  if ((i & i + 1) === 0) return null;           // no more elements on level

  var xs = this.xs_, l = xs.length;
  if (i + 1 >= l) return null;                  // no more elements at all

  // Are we moving from a left to a right child? If so, we know we can't go up
  // since otherwise the left child wouldn't have been the topmost ceiling.
  var search_upwards = i & 1;                   // right child before moving...
  i++;                                          // now we're at a new node

  // At this point we're at a node that may or may not be top-enough to be a
  // valid ceiling. Handle the easy case first:
  if (this.above_(v, xs[i]))
    // The node is a valid ceiling, so up-search if necessary and return it.
    return search_upwards ? this.topmost_ceiling_(v, i, depth)
                          : i;

  // This case is more interesting. The new node isn't a valid ceiling, so we
  // need to do a leaf-search and then move upwards from the first leaf that
  // works. If no leaf, then we return null.
  for (i <<= depth - infuse.msb(i); i < l; ++i)
    if (this.above_(v, xs[i]))
      return this.topmost_ceiling_(v, i, depth);

  // We hit the end without finding a suitable leaf, so we're done.
  return null;
};

methods.topmost_ceiling_ = function (v, i, depth) {
  // Binary search to identify the topmost node that satisfies the ceiling
  // property. This requires O(log log n) ordering checks (which I'm assuming
  // are arbitrarily expensive).
  var xs = this.xs_;
  for (var lower = 0, upper = depth; lower + 1 < upper;) {
    var mid = lower + upper >>> 1;
    if (this.above_(v, xs[i >>> mid])) lower = mid;
    else                               upper = mid;
  }
  return i >>> lower + 1;
};

// Find the first leaf with the ceiling property, then find its topmost ceiling.
// This is the only strategy we can use and still know that we have the leftmost
// ceiling. If there is no initial ceiling, then `initial_ceiling_` returns
// `null`.

methods.initial_ceiling_ = function (v, depth) {
  var xs = this.xs_;
  for (var i = 1 << depth, limit = xs.length; i < limit; ++i)
    if (this.above_(v, xs[i]))
      return this.topmost_ceiling_(v, i, depth);
  return null;
};

methods.get = function (k) {
  var map = this.map_;
  return Object.prototype.hasOwnProperty.call(map, k)
    ? this.xs_[map[k]]
    : infuse.fn.apply(this, arguments)(this, this.id());
};

methods.remove = function (k) {
  infuse.assert(!this.base_,
    'infuse: attempted to remove() from a derivative heapmap (because '
  + 'the heap map is a derivative, modifying it directly is illegal)');

  var xs   = this.xs_,
      map  = this.map_,
      keys = this.keys_;
  if (xs.length <= 1) return void 0;    // can't remove from an empty heap

  if (xs.length > 2)
    xs[1]   = xs.pop(),                 // standard last->first...
    keys[1] = keys.pop();
  else
    xs.pop(), keys.pop();               // first is last, so just pop

  if (xs.length > 1) {
    map[keys[1]] = 1;                   // update position map
    this.heapify_down_(1);              // then heapify down
  }

  delete map[k];
  ++this.version_;                      // record the change
  return this;
};

methods.pop = function () {
  var ks = this.keys_;
  if (ks.length <= 1) return void 0;
  var k = ks[1];
  this.remove(k);
  return k;
};

methods.peek = function () {
  return this.keys_[1];
};

methods.push_ = function (v, k) {
  var xs   = this.xs_,
      keys = this.keys_,
      map  = this.map_;

  if (Object.prototype.hasOwnProperty.call(map, k)) {
    // Update, not insert. Change the value, then heapify up or down
    // depending on the value ordering.
    var i = map[k],
        x = xs[i];
    xs[i] = v;
    return this.above_(v, x) ? this.heapify_up_(i)
                             : this.heapify_down_(i);
  } else {
    // Insert. This is the easy case: build a new container, add to end of
    // elements, and heapify up.
    var l = xs.length;
    xs.push(v);
    keys.push(k);
    return this.heapify_up_(map[k] = l);
  }
};

methods.swap_ = function (i, j) {
  var xs   = this.xs_,
      keys = this.keys_,
      map  = this.map_,
      tmp  = xs[i];
  xs[i] = xs[j];                        // swap the elements
  xs[j] = tmp;
  tmp = keys[i];                        // ... and the keys
  keys[i] = keys[j];
  keys[j] = tmp;
  map[keys[i]] = i;                     // update position map
  map[keys[j]] = j;
  return this;
};

methods.heapify_down_ = function (i) {
  var xs = this.xs_,
      l  = xs.length;

  if (i << 1 >= l)
    // Can't heapify down beyond the bottom of the heap
    return this;

  // Swap with the greater of the two children unless the current element is
  // greater than both.
  var left  = i << 1,
      right = left | 1,
      xi    = xs[i],
      xl    = xs[left],
      xr    = xs[right];      // this might not exist

  if (this.above_(xi, xl) && (right >= l || this.above_(xi, xr)))
    // We're done; neither child is greater.
    return this;

  // Swap with the greater of the two children.
  var swap_index = right >= l || this.above_(xl, xr) ? left : right;
  return this.swap_(i, swap_index).heapify_down_(swap_index);
};

methods.heapify_up_ = function (i) {
  var xs = this.xs_,
      up = i >>> 1;
  return up && this.above_(xs[i], xs[up])
    ? this.swap_(i, up).heapify_up_(up)
    : this;
};

});
});

// Generated by SDoc
// Infuse caches | Spencer Tipping
// Licensed under the terms of the MIT source code license

// Introduction.
// This module defines various kinds of caches for Infuse. These are used
// internally in cases where a weak reference map would ordinarily be used; for
// instance, caching compiled functions.

infuse.extend(function (infuse) {

infuse.cache = function (eviction_strategy) {
  var cache = {},       // cache data
      state = {};       // eviction strategy state
  eviction_strategy = eviction_strategy || infuse.cache.lru();
  var result = function (obj, generate) {
    return eviction_strategy(result, cache, state, obj, generate);
  };
  result(null, null);   // initialize the cache
  return result;
};

// Eviction strategies.
// An eviction strategy is notified whenever an entry is created, accessed, added,
// or removed from the cache. It then, potentially asynchronously, acts on the
// cache object to evict something if necessary. The eviction strategy owns the
// cache object exclusively; no user of the cache has access to it.

//   LRU eviction.
//   This is the most straightforward. We just keep a simple mapping from key to
//   access-time, and maintain a priority queue of evictable elements. This makes
//   cache access O(log n) in the number of elements, which is bounded above by
//   the cache capacity.

//   LRU eviction allows the user to evict an element at any point by calling the
//   `evict_one` method on the cache object. This can be useful if you want to
//   simulate weak references by slowly freeing memory over time, for instance.

  infuse.cache.lru = function (options) {
    options = options || {};
    var capacity = options.capacity || 1000,
        evict    = function (cache, state) {
          // Do nothing if there are no elements.
          if (!state.size) return false;
          --state.size;
          return delete cache[state.priority_queue.pop()];
        },
        clear    = function (cache, state) {
          for (var k in cache) delete cache[k];
          while (state.priority_queue.size()) state.priority_queue.pop();
          state.size = 0;
        };

    return function (f, cache, state, key, generate) {
      // Initialize the state if necessary. This happens before any objects are
      // inserted into the cache.
      if (key === null && generate === null) {
        state.size           = 0,
        state.access_counter = 0,
        state.priority_queue = infuse.heapmap(),
        f.hits               = 0,
        f.evictions          = 0,
        f.misses             = 0,
        f.evict_one          = function () {return evict(cache, state)},
        f.clear              = function () {return clear(cache, state)};
        return null;
      }

      // Prefix the key with something not used by Javascript. Otherwise we
      // risk colliding with native methods like Object.prototype.toString.
      key = '@' + key;

      // First, determine whether we have the item. If we do, just update the
      // access time and take no further action.
      var hit = cache[key];
      if (hit) {
        ++f.hits;
        state.priority_queue.push(++state.access_counter, key);
        return hit;
      }

      // Cache miss, so go ahead and generate a value and insert the result.
      // If we're over capacity, evict the least-recent access, which will be
      // the top element in the priority queue.
      var value = generate(key);
      ++f.misses;
      if (++state.size > capacity) {
        ++f.evictions;
        evict(cache, state);
      }
      state.priority_queue.push(++state.access_counter, key);
      return cache[key] = value;
    };
  };

});

// Generated by SDoc
// Infuse function promotion | Spencer Tipping
// Licensed under the terms of the MIT source code license

// Introduction.
// Javascript's function syntax is verbose, so Infuse supports implicit function
// promotion. This means that any method expecting a function can also accept
// other values like regular expressions or strings, and Infuse will produce a
// function from these other values.

// All Infuse extensions are written using `infuse.extend`. This binds a local
// variable `infuse` that won't change even if the user calls `infuse.hide()`
// (which removes the global reference).

infuse.extend(function (infuse) {

infuse.fn       = infuse.dispatcher('infuse.fn');
infuse.fn.cache = infuse.cache(infuse.cache.lru({capacity: 2048}));

// Automatic fn cache GC.
// If you have a long-running application that uses dynamically-generated
// functions, you may want to enable this. In most cases it won't matter much
// because the cache has a hard upper bound.

infuse.fn.auto_gc = function () {
  // Automatically clear out the function cache over time. There is no reason
  // to do this very quickly, since compiled functions don't hold any large
  // references (i.e. they aren't closures over user-specified data).
  //
  // In general it isn't safe to use intervals to control caches, since the
  // interval is a global reference that will prevent the whole cache from
  // being garbage-collected. However it is reasonable in this particular case
  // because the cache is already a global object.
  infuse.fn.cache_interval = setInterval(infuse.fn.cache.evict_one, 1000);

  infuse.unloaders.push(function () {
    clearInterval(infuse.fn.cache_interval);
  });
};

// Regular expressions.
// Regular expression functions return either a match object (for regexps with
// no capturing groups), or strings (for regexps with one or more capturing
// groups).

// | infuse.fn(/foo/)      -> function (x) {return /foo/.exec(x)}
//   infuse.fn(/f(o)o/)    -> function (x) {
//                              var result = /f(o)o/.exec(x);
//                              return result && result[1];
//                            }

// Regexps are most useful when used on sequences of strings:
// `infuse(...).map(/f(.)o/)`.

infuse.fn.alternatives.push(
  {accepts:   function (x) {return x.constructor === RegExp},
   construct: function (regexp) {
     return infuse.fn.regexp_group_count(regexp)
       // We have match groups; return them as an array.
       ? function (x) {
           var result = regexp.exec(x);
           return result && Array.prototype.slice.call(result, 1);
         }

       // No match groups; just return the matched string.
       : function (x) {
           var result = regexp.exec(x);
           return result && result[0];
         };
   }});

infuse.fn.regexp_group_count = function (regexp) {
  // Simple regexp parse: look for unescaped open-parens that aren't followed
  // by ?.
  for (var s = regexp.toString(),  groups     = 0,     group_check = -1,
           l = s.lastIndexOf('/'), escape     = false,
           i = 1,                  char_class = false, c;
       i < l; ++i) {
    c = s.charCodeAt(i);
    if      (escape)   escape = false;
    else if (c === 92) escape = true;                         // 92 = \
    else if (c === 93) char_class = false;                    // 93 = ]
    else if (char_class);
    else if (c === 91) char_class = true;                     // 91 = [
    else if (c === 40) group_check = i + 1, ++groups;         // 40 = (
    else if (i === group_check && c === 63) --groups;         // 63 = ?
  }
  return groups;
};

// Strings.
// There are two possibilities for strings. If the string begins with `[` or
// `.`, then it's assumed to be an object traversal path; otherwise it's
// compiled into a function. In the latter case, a second argument can be
// specified to bind closure variables. Function compilation is expensive, so we
// use the function cache to prevent unnecessary recompilation.

infuse.fn.is_path = function (s) {return /^\./.test(s)};
infuse.fn.is_js   = function (s) {return /^[-+\/~!$\w([{'"]/.test(s)};

infuse.fn.alternatives.push(
  {accepts:   function (x) {return x.constructor === String
                                && infuse.fn.is_path(x)},
   construct: function (s) {
     return infuse.fn.cache(s, function () {
       var path = infuse.inversion.parse_path(s);
       return function (x) {
         return infuse.inversion.at(path, x);
       };
     });
   }});

infuse.fn.alternatives.push(
  {accepts:   function (x) {return x.constructor === String
                                && infuse.fn.is_js(x)},
   construct: function (s, bindings) {
     // Function body case: prepend local variables in sorted order to make
     // sure that shadowing cases are distinct in the cache. We don't cache
     // the fully-instantiated closure; instead, we allocate a new closure
     // specific to the bindings that we have.
     return infuse.fn.cache(infuse.fn.binding_prefix(bindings) + s,
       function () {
         // The bindings passed to compile() are just for reference so that
         // compile() can bake in the right local variables ...
         return infuse.fn.compile(s, bindings);
       })(bindings);          // ... and this is where we pass them in.
   }});

// Function compilation.
// Compile a function with a list of bindings. This involves converting each
// binding key into a local variable.

infuse.fn.binding_prefix = function (bindings) {
  if (!bindings) return '';
  var bindings = [];
  for (var k in bindings)
    if (Object.prototype.hasOwnProperty.call(bindings, k))
      bindings.push(k);
  return bindings.sort().join(',') + ':';
};

infuse.fn.body_arity = function (body_string) {
  // Find the underscore-variable with the largest subscript. We support up to
  // _9, where _1 (also called _) is the first argument.
  for (var formals = body_string.match(/_\d?/g) || [],
           i       = 0,
           l       = formals.length,
           max     = +!!formals.length;
       i < l; ++i)
    max = Math.max(max, +formals[i].substr(1));
  return max;
};

infuse.fn.compile = function (code, bindings) {
  var locals = [], formals = [];

  // Alias each binding into a local variable.
  for (var k in bindings)
    if (Object.prototype.hasOwnProperty.call(bindings, k))
      locals.push('var ' + k + ' = _.' + k + ';\n');

  // Now build the list of formals.
  for (var i = 0, l = infuse.fn.body_arity(code); i < l; ++i)
    formals.push('_' + (i + 1));

  return new Function(
    '_',
    locals
    + 'return function (' + formals.join(', ') + ') {\n'
      + (formals.length ? 'var _ = _1;\n' : '')
      + 'return ' + code + ';\n'
    + '};');
};

// Functions.
// If we omit this, then it becomes impossible to pass in regular functions as
// functions. Putting it at the end makes it a little faster for the no-conversion
// fast case.

infuse.fn.alternatives.push(
  {accepts:   function (x) {return x instanceof Function},
   construct: function (x) {return x}});

});

// Generated by SDoc
// Infuse arrays | Spencer Tipping
// Licensed under the terms of the MIT source code license

// Infuse arrays.
// Infuse gives you two options for working with arrays. You can promote an
// existing array, in which case the `force()` method will provide no new data and
// will throw an error. Alternatively, you can invoke `infuse.array()` on a
// generator function to create an array-backed lazy sequence. If you do this,
// `force()` will add elements to the end of the array if any are available.

// A secondary consequence of using a generator function is that derivative
// arrays, objects, etc, are themselves lazy. In these cases, forcing derivative
// `map`, `filter`, etc results will cause more elements to be dynamically
// generated and transformed accordingly. (Internally this happens when the `pull`
// method is called.)

infuse.extend(function (infuse) {
infuse.type('array', function (array, methods) {

// Mixins.
// Arrays are "pulling" collections: derivatives are linked to their sources, not
// the other way around.

infuse.mixins.pull(methods);

// Array state.
// Every Infuse array is backed by a Javascript array. If the backing was provided
// as a constructor argument, then we aren't allowed to modify it; so the sequence
// is considered to be definite and can't have a generator.

// Otherwise the sequence is a generated array, in which case we allocate a
// private backing and fill it as the user forces things.

methods.initialize = function (xs_or_f, base) {
  if (xs_or_f instanceof Function)
    this.xs_        = [],
    this.base_      = base,
    this.generator_ = xs_or_f,
    this.version_   = -1,
    this.pull();
  else
    this.xs_        = xs_or_f instanceof Array
                      ? xs_or_f
                      : infuse.toa(xs_or_f),
    this.base_      = null,
    this.generator_ = null,
    this.version_   = 1;
};

// Size is always expressed as the number of items currently realized, not the
// eventual size of a lazy sequence. Any given lazy sequence will be both finite
// (as its size is finite) and indefinite at the same time, and operations such as
// `map` and `flatmap` will apply eagerly to the currently-realized part.

methods.size = function () {return this.pull().xs_.length};

// We mixin the `pull` behavior, which relies on this `push_` method to actually
// add things to the array. We don't need to worry about versioning.

methods.push_ = function (v, k) {
  this.xs_.push(v);
  return this;
};

// Derivatives.
// Laziness requires that we pass on certain metadata about the base whenever we
// construct any derivative. To do this, we have the derivative link to its base
// so that any new elements on the base can be transformed accordingly.

methods.derivative = function (generator) {
  var f = infuse.fn.apply(this, arguments);
  return infuse.array(f, this);
};

// Traversal.
// A generator is a stateful iterator that takes an emitter function and invokes
// it once for each item in the array. It re-checks the array's size each time it
// is called, so a generator can represent a collection whose size changes over
// time.

methods.generator = function () {
  var i = 0, self = this;
  return function (emit) {
    for (var xs = self.pull().xs_, l = xs.length; i < l;)
      // It's important to do the increment here so that it happens even if we
      // break out of the loop.
      if (emit(xs[i], i++) === false) return false;
  };
};

// Retrieval.
// Technically we just need to implement `get` here. `first` and `last` can, in
// theory, be derived from `each`, `size`, and `get`. However, doing things that
// way is inefficient for arrays because we have direct access to the elements.

methods.get = function (n, fn) {
  var xs = this.pull().xs_;

  // get() -> the current backing array (don't modify this!)
  if (n === void 0) return xs;

  // get(n) -> xs[n] or xs[n + length] if n is negative
  if (typeof n === typeof 0 || n instanceof Number)
    if (n === n >> 0)
      // n is an integer; use direct indexing (but wrap if negative)
      return xs[n < 0 ? xs.length + n : n];
    else {
      // n is a float; use interpolation.
      var f  = arguments.length > 1
               ? infuse.fnarg(arguments, 1)
               : function (a, b, x) {return a + (b-a)*x},
          i1 = (n < 0 ? xs.length : 0) + Math.floor(n),
          i2 = i1 + 1,
          x  = n - i1;
      return f(xs[i1], xs[i2], x);
    }

  // get([x1, x2, x3, ...]) = [get(x1), get(x2), ...]
  if (n instanceof Array) {
    for (var r = [], i = 0, l = n.length; i < l; ++i) r.push(this.get(n[i]));
    return r;
  }

  // get(...) = fn(...)(this, this.id())
  return infuse.fn.apply(this, arguments)(this, this.id());
};

methods.first = function (n) {
  var xs = this.get();

  // first() -> the single first element
  if (n === void 0) return xs[0];

  // first(n) -> infuse([x0, x1, ..., xn-1])
  if (typeof n === typeof 0 || n instanceof Number)
    return infuse.array(xs.slice(0, n < 0 ? xs.length + n : n));

  // first(f) -> the first element that satisfies f, or null
  var f = infuse.fn.apply(this, arguments);
  for (var i = 0, l = xs.length; i < l; ++i)
    if (f(xs[i], i)) return xs[i];
  return null;
};

methods.last = function (n) {
  var xs = this.get(),
      xl = xs.length;

  // last() -> the single last element
  if (n === void 0) return xs[xl - 1];

  // last(n) -> infuse([xn, xn+1, ..., xl-1])
  if (typeof n === typeof 0 || n instanceof Number)
    // Check for n == 0 to save an array copy if at all possible
    return infuse.array(n === 0 ? xs : xs.slice(n < 0 ? xl + n : n));

  // last(f) -> the last element that satisfies f, or null
  var f = infuse.fn.apply(this, arguments);
  for (var i = xl - 1; i >= 0; ++i)
    if (f(xs[i], i)) return xs[i];
  return null;
};

});     // end infuse.type('array')

// Array promotion.
// This hook allows you to say `infuse([1, 2, 3])` and get back an `infuse.array`
// object.

infuse.alternatives.push(
  {accepts:   function (x) {return x instanceof Array},
   construct: function (x) {return infuse.array(x)}});

});

// Generated by SDoc
// Infuse objects | Spencer Tipping
// Licensed under the terms of the MIT source code license

// Infuse objects.
// Like Infuse arrays, objects can be constructed either by wrapping an existing
// object or by specifying a generator function. If you specify a generator, the
// object's value (as returned by `get`, etc) will be updated as new elements
// become available.

// Infuse objects are not considered to be ordered unless you call `keys` or
// `values`. Each of these methods takes a sorted snapshot of the key list to
// guarantee traversal order; so you could request `keys` and `values` and know
// that `k[0]` corresponded to `v[0]`, for instance.

infuse.extend(function (infuse) {
infuse.type('object', function (object, methods) {

// Use pull-propagation updating
infuse.mixins.pull(methods);

// Object state.
// Like an Infuse array, an object has a backing which may be externally
// allocated, and for internally-allocated backings it also has a generator and a
// base.

methods.initialize = function (o_or_f, base) {
  if (o_or_f instanceof Function)
    this.o_         = {},
    this.base_      = infuse.assert(base,
                        'infuse: attempted to construct a derivative '
                      + 'object without specifying a base'),
    this.generator_ = o_or_f,
    this.version_   = -1,
    this.journal_   = infuse.heapmap(),
    this.pull();
  else
    this.o_         = o_or_f,
    this.base_      = null,
    this.generator_ = null,
    this.version_   = 1,
    this.journal_   = null;
};

// Size is the number of distinct key/value pairs stored in the object. This
// function needs to be amortized O(1), so we use the journal to tell us how many
// items we have.

methods.size = function () {return this.pull().journal().size()};

methods.push_ = function (v, k) {
  var o = this.o_;
  o[k] = v;
  this.journal().push(this.version_, k);
  return this;
};

// Derivatives.
// Objects can have derivatives just like arrays can, but the behavior is
// different. An object derivative means "the object will gain new key/value
// mappings in the future", much as an array derivative means "the array will grow
// in the future". So it's a partial journal of changes that will be made to the
// object.

// The main difference between the two is the degree of assumption about
// immutability. Arrays are only allowed to grow; we assume that elements already
// in the array won't change. Objects, on the other hand, might receive value
// updates for existing keys; a common case of this is when you're indexing
// something. This means that a simple array journal has the potential to be
// arbitrarily larger than the object it represents (since it's storing each
// intermediate change).

// As a result, we don't keep the journal this way. Instead, we just use an object
// that maps each key to the last version at which it was modified. Each generator
// can then search this object and apply updates. This makes searching O(n) when
// the object has been updated, O(1) otherwise.

methods.derivative = function (generator) {
  var f = infuse.fn.apply(this, arguments);
  return infuse.object(f, this);
};

methods.journal = function () {
  var j = this.journal_;
  if (!j) {
    var o = this.o_,
        v = this.version_;

    // Update all keys to the current version.
    j = this.journal_ = infuse.heapmap();
    for (var k in o)
      if (Object.prototype.hasOwnProperty.call(o, k))
        j.push(v, k);
  }
  return j;
};

// Traversal.
// This is tricky. We need to go through the object's keys in the right order, but
// we can't use the `keys` function to do it because `keys` is defined in terms of
// `generator`. Instead, we maintain a maxheap of key -> version and use that to
// pull changes.

// Heap generators aren't the same as generators for other objects; see
// `infuse.heapmap` for details.

methods.generator = function () {
  var journal_generator = this.journal().generator(),
      o                 = this.o_;
  return function (emit) {
    // The version generator passes the version as 'v' and the key as 'k'; we
    // just need to translate that into our value for the key.
    return journal_generator(function (v, k) {return emit(o[k], k)});
  };
};

// Retrieval.
// Objects don't support `first` or `last`, but they do support `get`, which takes
// a string or array of strings.

methods.get = function (k) {
  var o = this.pull().o_;

  // get() -> the current backing object (don't modify this!)
  if (k === void 0) return o;

  // get(k) -> o[k]
  if ((typeof k === typeof '' || k instanceof String) &&
      Object.prototype.hasOwnProperty.call(o, k))
    return o[k];

  // get([k1, k2, ...]) = [get(k1), get(k2), ...]
  if (k instanceof Array) {
    for (var r = [], i = 0, l = k.length; i < l; ++i) r.push(this.get(k[i]));
    return r;
  }

  // get(...) = fn(...)(this, this.id())
  return infuse.fn.apply(this, arguments)(this, this.id());
};

});

// Object promotion.
// Detecting a vanilla object turns out to be tricky. We can't do the obvious `x
// instanceof Object` because everything is an instance of `Object`. Long story
// short, we have to rely on `Object.prototype.toString` to tell us.

var obj_to_string = Object.prototype.toString.call({});
infuse.alternatives.push(
  {accepts:   function (x) {return Object.prototype.toString.call(x) ===
                                   obj_to_string},
   construct: function (x) {return infuse.object(x)}});

});

// Generated by SDoc
// Infuse multiobjects | Spencer Tipping
// Licensed under the terms of the MIT source code license

// Infuse multi-objects.
// These are just like Infuse objects, but they support multiple values for a
// given key.

infuse.extend(function (infuse) {
infuse.type('multiobject', function (multiobject, methods) {

// Use pull-propagation updating
infuse.mixins.pull(methods);

// Multiobject state.
// Like objects, multiobjects use heapmaps to manage versioning. Unlike objects,
// converting an existing object to a multiobject requires linear time and space.

methods.initialize = function (o_or_f, base) {
  this.o_       = {};
  this.size_    = 0;
  this.journal_ = infuse.heapmap();

  if (o_or_f instanceof Function)
    this.version_   = -1,
    this.generator_ = o_or_f,
    this.base_      = infuse.assert(base,
      'infuse: attempted to create a derivative multiobject without '
    + 'specifying a base'),
    this.pull();
  else {
    this.version_ = 0;
    this.generator_ = null,
    this.base_      = null;
    if (o_or_f)
      for (var k in o_or_f)
        if (Object.prototype.hasOwnProperty.call(o_or_f, k))
          this.push(o_or_f[k], k);
  }
};

// Size is the number of key/value pairs stored, with the provision that multiple
// values per key count independently. So {foo: 2, foo: 3} has size 2.

methods.size = function () {return this.pull().size_};

methods.push_ = function (v, k) {
  var o = this.o_;

  // Even though all values we assign are truthy, it's still important to make
  // this distinction. Otherwise push_(x, 'toString') would cause a runtime
  // error.
  if (Object.prototype.hasOwnProperty.call(o, k)) o[k].push(v);
  else                                            o[k] = [v];

  this.journal().push(this.version_, k);
  ++this.size_;
  return this;
};

// Derivatives.
// Objects can have derivatives just like arrays can, but the behavior is
// different. An object derivative means "the object will gain new key/value
// mappings in the future", much as an array derivative means "the array will grow
// in the future". So it's a partial journal of changes that will be made to the
// object.

// The main difference between the two is the degree of assumption about
// immutability. Arrays are only allowed to grow; we assume that elements already
// in the array won't change. Objects, on the other hand, might receive value
// updates for existing keys; a common case of this is when you're indexing
// something. This means that a simple array journal has the potential to be
// arbitrarily larger than the object it represents (since it's storing each
// intermediate change).

// As a result, we don't keep the journal this way. Instead, we just use an object
// that maps each key to the last version at which it was modified. Each generator
// can then search this object and apply updates. This makes searching O(n) when
// the object has been updated, O(1) otherwise.

methods.derivative = function (generator) {
  var f = infuse.fn.apply(this, arguments);
  return infuse.multiobject(f, this);
};

// Traversal.
// This works like the one for `infuse.object`, but emits a separate key/value
// pair for each value mapped by a key.

methods.generator = function () {
  var journal_generator = this.journal().generator(),
      o                 = this.o_;
  return function (emit) {
    // Expand each value-array and invoke emit() multiple times per key
    return journal_generator(function (v, k) {
      for (var i = 0, xs = o[k], l = v.length; i < l; ++i)
        if (emit(xs[i], k) === false) return false;
    });
  };
};

// Retrieval.
// The `get` method returns an array of values for any existing key.

methods.get = function (k) {
  var o = this.pull().o_;

  // get() -> o (don't modify this!)
  if (k === void 0) return o;

  // get(k) -> o[k]
  if ((typeof k === typeof '' || k instanceof String) &&
      Object.prototype.hasOwnProperty.call(o, k))
    return o[k];

  // get([k1, k2, ...]) = [get(k1), get(k2), ...]
  if (k instanceof Array) {
    for (var r = [], i = 0, l = k.length; i < l; ++i) r.push(this.get(k[i]));
    return r;
  }

  // get(...) = fn(...)(this)
  return infuse.fn.apply(this, arguments)(this, this.id());
};

});
});

// Generated by SDoc
// Infuse futures | Spencer Tipping
// Licensed under the terms of the MIT source code license

// Introduction.
// A future is a container for a value that will become available later on,
// generally by an asynchronous callback. Futures represent callbacks that have
// not yet been invoked, allowing you to transform the values they will receive or
// otherwise manipulate them as objects.

// Things you can do trivially with futures that are more difficult with just
// callbacks include having an indefinite number of listeners for the result and
// combining N pending results into a single object. Futures are also useful for
// chaining asynchronous computations, but callbacks don't make this particularly
// difficult to begin with.

infuse.extend(function (infuse) {
infuse.type('future', function (future, methods) {

infuse.mixins.push(methods);

// Future state.
// Each future contains a key and a result; the key contextualizes the value and
// is emitted from generators when the value is delivered. Futures have two
// states, undelivered and delivered, and the only transition that happens is from
// undelivered to delivered. So for most purposes they are immutable, and they
// converge to immutable objects. (If you don't want this convergence, you should
// use a signal instead.)

// Because we have this immutability, we can unlink all derivatives once the state
// is finalized.

methods.initialize = function (generator, base) {
  this.listeners_ = {};         // null once the future is decided
  this.bases_     = {};         // null once the future is decided
  this.value_     = null;
  this.key_       = null;
  this.generator_ = null;       // generated on demand

  if (generator) {
    infuse.assert(base,
      'infuse: attempted to construct a derivative future without specifying '
    + 'a base');

    var self = this;
    generator(function (v, k) {return self.push(v, k)}, this.id());
    this.bases_[base.id()] = base;
  }
};

methods.size  = function () {return +!this.listeners_};
methods.key   = function () {return this.key_};
methods.value = function () {return this.value_};

// Derivatives.
// Future derivatives are push-notified, not pull-notified, so they work
// differently. We create the derivative and doubly-link it to the base for
// reasons I'll explain in more detail later. At that point we don't need to do
// anything else until we get a value through `push`.

methods.derivative = function (generator) {
  var f = infuse.fn.apply(this, arguments);
  return infuse.future(f, this);
};

methods.generator = function () {
  var g = this.generator_;
  if (!g) {
    var self = this;
    g = this.generator_ = function (emit, id) {
      var ls = self.listeners_;
      if (ls) id != null && (ls[id] = emit);
      else    return emit(self.value_, self.key_);
    };
  }
  return g;
};

methods.push = function (v, k) {
  infuse.assert(this.listeners_,
    'infuse: attempted to push to an already-decided future');

  // Alert listeners...
  var ls = this.listeners_;
  for (var id in ls)
    if (Object.prototype.hasOwnProperty.call(ls, id))
      ls[id](v, k);

  this.listeners_ = null;       // ... and then free them; we are now immutable
  this.value_     = v;
  this.key_       = k;
  return this;
};

// Retrieval.
// Futures are modeled sort of like objects with a single key/value after they're
// decided, and no existence at all before they're decided.

methods.get = function (k) {
  // get() -> {} if undecided, {k: v} if decided
  if (k === void 0)
    if (this.listeners_) return {};
    else {
      var result = {};
      result[this.key_] = this.value_;
      return result;
    }

  // get(k) -> v if decided and k === key, otherwise null
  if (k === this.key_) return this.value_;
  else                 return null;
};

// Callback interface.
// You can use a future to invoke a callback, and you can also create a callback
// that will trigger the future when you invoke it. Each of these use cases ties a
// key to the callback, which is useful for things like error processing. See the
// future tests for examples.

// If `target` is not a string, it is assumed to be a function that can be
// promoted with `infuse.fn`. This is useful when you want to capture all
// outcomes: `on(/.*/, callback_fn)`.

methods.on = function (target, callback) {
  var f = typeof target === typeof '' || target instanceof String
          ? function (x) {return x === target}
          : infuse.fn(target);

  this.generator()(function (v, k) {if (f(k)) callback(v, k)},
                   infuse.gen_id());
  return this;
};

// Futures can be resolved at most once, so these methods do the same thing.
// (But this is not the case for signals.)
methods.once = methods.on;

methods.trigger = function (k) {
  var self = this;
  return function (v) {self.push(v, k)};
};

});
});

// Generated by SDoc
// Infuse signals | Spencer Tipping
// Licensed under the terms of the MIT source code license

// Introduction.
// A signal is just like a future, but it can be resolved asynchronously multiple
// times. As a result, it retains its listener list, which means that derivatives
// are live until the base is freed.

infuse.extend(function (infuse) {
infuse.type('signal', function (signal, methods) {

infuse.mixins.push(methods);

// Signal state.
// Signals retain the last key/value they took on, and they also maintain the list
// of listeners indefinitely.

methods.initialize = function (generator, base) {
  this.listeners_ = {};         // stored until explicitly detached
  this.bases_     = {};         // stored until explicitly detached
  this.value_     = null;
  this.key_       = null;
  this.generator_ = null;       // generated on demand
  this.size_      = 0;          // number of values processed by the signal

  if (generator) {
    infuse.assert(base,
      'infuse: attempted to construct a derivative signal without specifying '
    + 'a base');

    var self = this;
    generator(function (v, k) {return self.push(v, k)}, this.id());
    this.bases_[base.id()] = base;
  }
};

methods.size  = function () {return this.size_};
methods.key   = function () {return this.key_};
methods.value = function () {return this.value_};

// Derivatives.
// Like futures, signals don't have base objects since updates are propagated
// forwards.

methods.derivative = function (generator) {
  var f = infuse.fn.apply(this, arguments);
  return infuse.signal(f, this);
};

methods.generator = function () {
  var g = this.generator_;
  if (!g) {
    var self = this;
    g = this.generator_ = function (emit, id) {
      infuse.assert(id != null,
        'infuse: attempted to construct a push generator without specifying '
      + 'an ID (this may cause space leaks, so it is disallowed)');
      self.listeners_[id] = emit;
    };
  }
  return g;
};

methods.push = function (v, k) {
  // Alert listeners...
  var ls = this.listeners_;
  for (var id in ls)
    if (Object.prototype.hasOwnProperty.call(ls, id))
      ls[id](v, k);

  // ... then track the signal's current state
  this.value_ = v;
  this.key_   = k;
  ++this.size_;
  return this;
};

// Retrieval.
// Signals behave just like futures that change if decided again. They always
// consist of a single key/value mapping, and sometimes the key is empty or null.

methods.get = function (k) {
  // get() -> {} if undecided, {k: v} if decided
  if (k === void 0) {
    var result = {};
    if (this.key_ != null) result[this.key_] = this.value_;
    return result;
  }

  // get(k) -> v if decided and k === key, otherwise null
  if (k === this.key_) return this.value_;
  else                 return null;
};

// Callback interface.
// You can use a signal to invoke a callback, and you can also create a callback
// that will trigger the signal when you invoke it.

methods.on = function (target, callback) {
  var f = typeof target === typeof '' || target instanceof String
          ? function (x) {return x === target}
          : infuse.fn(target);

  this.generator()(function (v, k) {if (f(k)) callback(v, k)},
                   infuse.gen_id());
  return this;
};

// Similar to `on` is `once`, which creates a callback that is invoked only once
// and then removed from the listener list. This can prevent a space leak for
// cases where you need transient anonymous listeners.

methods.once = function (target, callback) {
  var f    = typeof target === typeof '' || target instanceof String
             ? function (x) {return x === target}
             : infuse.fn(target),
      id   = infuse.gen_id(),
      self = this;

  this.generator()(function (v, k) {
                     if (f(k)) {
                       delete self.listeners_[id];
                       callback(v, k);
                     }
                   }, id);
  return this;
};

methods.trigger = function (k) {
  var self = this;
  return function (v) {self.push(v, k)};
};

});
});

// Generated by SDoc
// Infuse methods | Spencer Tipping
// Licensed under the terms of the MIT source code license

// Introduction.
// This module defines most of the methods that are common to all Infuse types.
// Each of the methods defined here is based on implementations of `derivative`
// and `generator`.

infuse.extend(function (infuse, methods) {

// Instance identification.
// For various reasons it becomes useful to have an object-key reference for any
// Infuse object. This value is used as the second argument to functions given to
// `get`.

methods.id = function () {
  var id = this.id_;
  if (!id) id = this.id_ = infuse.gen_id();
  return id;
};

// Key/value querying.
// These are simply array objects based on the values emitted by the generator.

methods.keys = function () {
  var g = this.generator();
  return infuse.array(function (emit, id) {
    g(function (v, k) {return emit(k, k)}, id);
  }, this);
};

// This just converts the object to an Infuse array. It's important that this
// method returns a distinct object; otherwise things like detach() might be
// sent to the wrong receiver.
methods.values = function () {
  var g = this.generator();
  return infuse.array(g, this);
};

// Traversal.
// The generator order can be used to define `each`; we just throw the generator
// away at the end. There is no ID associated with an `each` operation, so it will
// throw an error for asynchronous objects. (If you want to handle asynchronous
// operations, you should use `on`.)

methods.each = function (fn) {
  var f = infuse.fn.apply(this, arguments);
  this.generator()(f);
  return this;
};

// Sequence transformations.
// The usual suspects: `map`, `flatmap`, etc. These apply to all data types based
// on the semantics of `derivative` and `generator`.

methods.map = function (fn) {
  var f = infuse.fn.apply(this, arguments),
      g = this.generator();
  return this.derivative(function (emit, id) {
    g(function (v, k) {return emit(f(v, k), k)}, id);
  });
};

methods.flatmap = function (fn) {
  var f = infuse.fn.apply(this, arguments),
      g = this.generator();
  return this.derivative(function (emit, id) {
    g(function (v, k) {var y = f(v, k);
                       return y && infuse(f(v, k)).each(emit)}, id);
  });
};

methods.filter = function (fn) {
  var f = infuse.fn.apply(this, arguments),
      g = this.generator();
  return this.derivative(function (emit, id) {
    g(function (v, k) {if (f(v, k)) return emit(v, k)}, id);
  });
};

methods.mapfilter = function (fn) {
  var f = infuse.fn.apply(this, arguments),
      g = this.generator();
  return this.derivative(function (emit, id) {
    g(function (v, k) {
      var y = f(v, k);
      if (y) return emit(y, k);
    }, id);
  });
};

// Reductions.
// Most systems treat reductions as being generic across lazy and strict
// sequences. Infuse can't do this, however, because some sequences are push-lazy
// (and besides, Javascript isn't idiomatically lazy enough to have pull-lazy
// sequences and lazy right-folds anyway).

// As a result, we implement two forms of `reduce`. The eager one, `reduce`,
// returns a final answer that is not wrapped in an Infuse object, while the lazy
// one, `reductions`, returns a result whose value may be updated as the
// underlying sequence gains values.

// A relevant example is the difference when dealing with futures. Suppose you
// have a future `f` that will end up delivering `5`. If you call
// `f.reduce(0, '_1 + _2')` and `f` is not yet delivered, you'll get `0` back as
// the future is said to have no elements.

// If, on the other hand, you invoke `f.reductions(0, '_1 + _2')`, you'll get a
// future that is initially undelivered and then becomes `5` when the first future
// is delivered. (Reducing a signal is a little more interesting, since signal
// reductions continue to update and accumulate.)

// More intuitively, a signal is like a lazy sequence whose index is time.
// Obviously you can't faithfully reduce it in a strict way, since it doesn't have
// any kind of "last" value. So if you want to fold it up, the best you can do is
// observe it at each change point, and to do that you ask for all of its
// reductions.

methods.reductions = function (into, fn) {
  var f = infuse.fnarg(arguments, 1),
      g = this.generator();
  return this.derivative(function (emit, id) {
    g(function (v, k) {return emit(into = f(into, v, k), k)}, id);
  });
};

methods.reduce = function (into, fn) {
  var f = infuse.fnarg(arguments, 1);
  this.each(function (v, k) {into = f(into, v, k)});
  return into;
};

// Indexing.
// You can group or index a sequence's values into an object. The index function
// should take an element (and optionally its key, position, whatever), and return
// a string for the index.

methods.index = function (fn) {
  var f = infuse.fn.apply(this, arguments),
      g = this.generator();
  return infuse.object(function (emit, id) {
    g(function (v, k) {return emit(v, f(v, k))}, id);
  }, this);
};

methods.group = function (fn) {
  var f = infuse.fn.apply(this, arguments),
      g = this.generator();
  return infuse.multiobject(function (emit, id) {
    g(function (v, k) {return emit(v, f(v, k))}, id);
  }, this);
};

});

// Generated by SDoc
module.exports = infuse;
