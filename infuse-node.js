// Infuse core | Spencer Tipping
// Licensed under the terms of the MIT source code license

// Introduction.
// All Infuse objects support a large set of core methods. Many of these methods
// are implemented in terms of other, type-specific methods; for example, `each`
// is a type-specific method that is used for `all` and `any`. This file defines
// the global `infuse` function and the mechanism used to define type-specific
// infuse implementations.

(function () {
  var original_infuse = typeof infuse !== typeof void 0 ? infuse : undefined,
      original_$i     = typeof $i     !== typeof void 0 ? $i     : undefined;

  var dispatcher = function (name) {
    var result = function (x) {
      for (var xs = result.alternatives, i = xs.length - 1, t; i >= 0; --i)
        if ((t = xs[i]).accepts.apply(t, arguments))
          return t.construct.apply(t, arguments);
      throw new Error(
        name + '(' + Array.prototype.slice.call(arguments).join(', ')
             + ') is not supported (no alternative accepted the supplied '
             + 'arguments)');
    };

    result.alternatives = [];
    result.accepts = function (x) {
      for (var xs = result.alternatives, i = xs.length - 1, t; i >= 0; --i)
        if ((t = xs[i]).accepts.apply(t, arguments))
          return true;
      return false;
    };

    return result;
  };

  var infuse_global = dispatcher('infuse');
  infuse_global.dispatcher = dispatcher;

  infuse_global.hide = function (all) {
    if ($i === infuse_global)
      $i = original_$i,
      original_$i = null;

    if (all && infuse === infuse_global)
      infuse = original_infuse,
      original_infuse = null;

    return infuse_global;
  };

  $i = infuse = infuse_global;
})();

// Bind a local variable so that extend() works even after hiding the global.
(function (infuse) {
  infuse.extend = function (body) {
    return body.call(infuse, infuse, infuse.prototype) || infuse;
  };
})(infuse);

infuse.extend(function (infuse) {

// Infuse function instantiation.
// We don't really advertise this because it isn't generally useful, but you can
// instantiate the global Infuse object as a class to enable prototype
// inheritance. Infuse uses this internally when you define new types.

var as_ctor = {};
infuse.alternatives.push(
  {accepts:   function (x) {return x === as_ctor},
   construct: function ()  {}});

// Methods and type definition.
// All global methods are installed on `infuse.prototype`. Subclasses then inherit
// from `infuse` using the usual Javascript inheritance pattern.

infuse.type = function (name, body) {
  var ctor = infuse[name] = function () {
    if (this.constructor !== ctor) {
      var result = new ctor();
      result.initialize.apply(result, arguments);
      return result;
    }
  };
  (ctor.prototype = new infuse(as_ctor)).constructor = ctor;
  return body.call(ctor, ctor, ctor.prototype) || ctor;
};

infuse.mixins = {};
infuse.mixin = function (name, body) {
  var methods = {};
  body.call(methods, methods);

  return infuse.mixins[name] = function (proto) {
    // Mix methods into proto.
    for (var k in methods)
      if (Object.prototype.hasOwnProperty.call(methods, k))
        proto[k] = methods[k];
    return proto;
  };
};

// Infuse object passthrough.
// If you invoke `infuse()` on something that is already an Infuse object, the
// object is returned verbatim. This allows you to transparently promote
// non-Infuse objects.

infuse.alternatives.push(
  {accepts:   function (x) {return x instanceof infuse},
   construct: function (x) {return x}});

});

// Generated by SDoc
// Infuse utilities | Spencer Tipping
// Licensed under the terms of the MIT source code license

// Introduction.
// This module defines global functions on the `infuse` global.

infuse.extend(function (infuse) {

// Function constructors.
// Various commonly-used functions.

infuse.identity = function (x) {return x};
infuse.id       = infuse.identity;

infuse.always     = function (x) {return function () {return x}};
infuse.constantly = infuse.always;
infuse.k          = infuse.always;

infuse.tap = function (v, fn) {
  infuse.fnarg(arguments, 1)(v);
  return v;
};

// Ordering functions.
// These are useful when you're sorting things. All elements are considered
// distinct for orderings, so a â‰® a.

infuse.comparator_to_ordering = function (comparator) {
  return function (x, y) {return comparator(x, y) < 0};
};

infuse.comparator_from_ordering = function (ordering) {
  return function (x, y) {return ordering(x, y) ? -1 : 1};
};

// Internal functions.
// These are generally just used by Infuse.

var id = 0;
infuse.gen_id = function () {return 'infuse-' + ++id};

infuse.toa   = function (xs)    {return Array.prototype.slice.call(xs)};
infuse.slice = function (xs, n) {return Array.prototype.slice.call(xs, n)};

infuse.fnarg = function (args, i) {
  // Make a function from arguments[i] and beyond. O(n) in the number of
  // arguments, though in most cases the GC overhead probably outweighs the
  // complexity.
  return infuse.fn.apply(this, infuse.slice(args, i));
};

infuse.assert = function (x, message) {
  if (!x) throw new Error(message);
  return x;
};

infuse.assert_equal = function (x, y) {
  infuse.assert(x === y, x + ' != ' + y);
  return x;
};

});

// Generated by SDoc
// Infuse pull-propagation mixin | Spencer Tipping
// Licensed under the terms of the MIT source code license

// Introduction.
// All Infuse collections support some form of derivatives and dynamic updating.
// This mixin assumes the presence of a few instance variables and provides the
// methods required to create linked derivatives. To use this mixin, you need to
// define/maintain the following:

// | this.generator_       a generator object
//   this.version_         the current version of this object
//   this.push_pair(v, k)  a function that adds a new element to the object

// Given that, this mixin provides a complete implementation of pull-propagation,
// as well as defining a wrapper `push` method that takes care of version
// updating and derivative checking.

infuse.extend(function (infuse) {
infuse.mixin('pull', function (methods) {

// Trivial accessors.
// We assume the presence of `version_` and `generator_`. Of these, `generator_`
// is kept private because accessing it changes its state.

methods.version       = function () {return this.version_};
methods.is_derivative = function () {return !!this.generator_};

// Pull propagation.
// You can pull any collection with a base (it's a nop for independent
// collections). An invariant is that invoking `pull` with no arguments will cause
// the receiver to become up-to-date with the base. As a result, the receiver's
// version will bet set equal to the base's version.

methods.pull = function () {
  var g = this.generator_,
      v = g && g.version();

  // Invoking generators is potentially expensive, so only do it if there's a
  // version discrepancy.
  if (v && v > this.version_) {
    // Optimistically pre-increment the version so that any push_pair() calls
    // made by the generator will see the new version.
    ++this.version_;
    if (g.into(this) !== false) this.version_ = v;
  }
  return this;
};

methods.push = function (v, k) {
  ++this.version_;
  this.push_pair(v, k);
  return this;
};

// Sinking.
// You can sink the pairs generated by a pull collection. If you do this, you'll
// get a derivative.

methods.into = function (x) {
  
};

// Generators.
// Pull collections provide generators that are derived from two methods,
// `generator_state` and `generate`. See [pull-generator-src.md] for details.

methods.generator = function () {
  return infuse.pull_generator(this);
};

// Detaching.
// You can detach any pull-propagated collection from its source to allow the
// source to be garbage-collected. Doing this also enables the collection to be
// modified by using `push`. `detach` does nothing if the collection is already
// detached.

methods.detach = function () {
  if (this.generator_) this.generator_.detach_derivative(this);
  this.generator_ = null;
  return this;
};

});
});

// Generated by SDoc
// Infuse pull-generator | Spencer Tipping
// Licensed under the terms of the MIT source code license

// Introduction.
// A pull generator is usually backed by an underlying collection of some sort.
// Consumers of pairs pull them by calling `into`.

infuse.extend(function (infuse) {
infuse.type('pull_generator', function (pull_generator, methods) {

infuse.mixins.pull(methods);

// Pull-generator state.
// Pull-generators maintain an opaque `state` object that is handed to the
// `generate` method of the generator's source.

methods.initialize = function (generator) {
  this.generator_ = generator;
  this.state_     = generator.generator_state();

  // This is a transient, sort-of-dynamically-scoped variable.
  this.target_ = null;
};

methods.version = function () {return this.generator_.version()};
methods.tos     = function () {return '#<' + this.generator_ + '>'};

methods.push_pair = function (v, k) {
  infuse.assert(this.target_ != null,
    'infuse: attempted to push a pair to a disconnected pull-generator ('
  + 'this sometimes means that you created a derivative collection that '
  + 'you never ended up using, or that you somehow connected a pull-generator '
  + 'to an asynchronous source)');
  return this.target_.push_pair(v, k);
};

// Generator fusion.
// There is some subtle stuff going on here. First, notice that pull generators
// appear to be pull collections. This enables you to transform generator outputs
// lazily, which bypasses intermediate collection allocations.

// Second, you can construct multiple derivatives of a generator. If you do this,
// each derivative will pick up where the original generator begins, and the
// derivatives will consume elements independently.

methods.generator       = function () {return this};
methods.generator_state = function () {return this.state_};

methods.generate = function (target, state) {
  infuse.assert(this.target_ == null,
    'infuse: attempted to make a re-entrant call to a generator (this can '
  + 'happen if you have a circular generator transformation topology and no '
  + 'intermediate buffering collections)');

  this.target_ = target;
  var result = this.generator_.generate(target, state);
  this.target_ = null;
  return result;
};

methods.derivative = function (generator) {
  return infuse.pull_generator(generator);
};

});
});

// Generated by SDoc
// Infuse AA-tree | Spencer Tipping
// Licensed under the terms of the MIT source code license

// Introduction.
// A straightforward AA-tree implementation used as a key modification journal by
// objects and buffers. AA-trees have generators that traverse the key/value pairs
// in key-sorted order.

infuse.extend(function (infuse) {
infuse.type('aatree', function (aatree, methods) {

infuse.mixins.pull(methods);

// AA-tree state.
// We store the ordering function, which takes two values and returns true if the
// first should be stored to the left of the second. When searching for elements,
// equality is determined with `===`.

methods.initialize = function (lt, generator) {
  this.lt_        = lt ? infuse.fn(lt)
                       : function (a, b) {return a < b};
  this.root_      = null;
  this.size_      = 0;
  this.version_   = -1;
  this.generator_ = generator;
  this.first_     = null;
  this.last_      = null;

  this.pull();
};

methods.tos = function () {
  return (this.generator_ ? '#t<' : '#<')
       + this.map('_2 + ": " + _1').join(', ')
       + '>';
};

methods.internal_tos = function () {
  return this.internal_tos_(this.root_);
};

methods.internal_tos_ = function (node) {
  if (node) return node.k + '.' + node.level
                          + ' [' + this.internal_tos_(node.l) + ']'
                          + ' [' + this.internal_tos_(node.r) + ']';
  return '';
};

// Node state.
// Each node contains a key, value, level, left child, and right child. Nodes are
// not parent-linked.

methods.aatree_node_ = function (v, k, level, l, r) {
  this.v     = v;
  this.k     = k;
  this.level = level;
  this.l     = l;
  this.r     = r;
};

// Rebalancing.
// Skew operation, which does this:

// |    L <- [T]              [L] -> T
//     / \      \     ->     /      / \
//    A   B      R          A      B   R

// The brackets indicate reference; for the skew operation, the parent's child
// pointer may change from T to L.

methods.skew_ = function (node) {
  if (!node) return node;
  var l = node.l;
  if (l && l.level === node.level) {
    node.l = l.r;
    l.r    = node;
    return l;
  }
  return node;
};

// Split operation:

// |                           [R]
//      [T] -> R -> X         /   \
//     /      /         ->   T     X
//    A      B              / \
//                         A   B

// Just like in `skew`, we return the parent's new child.

methods.split_ = function (node) {
  if (!node) return node;
  var r  = node.r;
  var rr = r && r.r;
  if (rr && node.level === rr.level) {
    node.r = r.l;
    r.l    = node;
    ++r.level;
    return r;
  }
  return node;
};

// Insertion.
// Destructively inserts a node into the tree, returning the new root. This
// implementation of AA trees supports multiple identical instances of the same
// key/value pair. Algorithms here are based on the implementation described in
// http://user.it.uu.se/~arnea/ps/simp.ps.

methods.insert_ = function (node, v, k) {
  if (node == null) return new methods.aatree_node_(v, k, 1, null, null);
  else if (this.lt_(k, node.k)) node.l = this.insert_(node.l, v, k);
  else                          node.r = this.insert_(node.r, v, k);
  return this.split_(this.skew_(node));
};

// Deletion.
// Algorithm here is based on Wikipedia, original AA-tree paper, and Javascript
// implementation at
// http://thomaswilburn.net/typedefs/index.php/tree/aa/aa_trees.html.

// The idea here is that there are a few different cases, which we test for in
// this order. First, is the to-be-removed node to the left? Then we delegate. Is
// it strictly to the right? (Hence the `===` check; not-less-than isn't the same
// as greater than.) We delegate for this too. As a third option, we can simply
// delete ourselves if we're a leaf.

// The remaining two cases happen if we are not a leaf but we need to delete
// ourselves. The idea is to find the nearest leaf that _can_ be deleted, then
// take over the value from that leaf.

methods.remove_ = function (node, k) {
  if (!node || !node.l && !node.r) return null;
  else if (this.lt_(k, node.k)) node.l = this.remove_(node.l, k);
  else if (k !== node.k)        node.r = this.remove_(node.r, k);
  else if (!node.l) {
    for (var next = node.r; next.l; next = next.l);
    node.r = this.remove_(node.r, next.k);
    node.k = next.k, node.v = next.v;
  } else {
    for (var prev = node.l; prev.r; prev = prev.r);
    node.l = this.remove_(node.l, prev.k);
    node.k = prev.k, node.v = prev.v;
  }

  var minlevel = 1 + Math.min(node.l ? node.l.level : 0,
                              node.r ? node.r.level : 0);
  if (minlevel < node.level) {
    node.level = minlevel;
    if (node.r && minlevel < node.r.level) node.r.level = minlevel;
  }
  if (node = this.skew_(node))
    if (node.r = this.skew_(node.r))
      node.r.r = this.skew_(node.r.r);
  if (node = this.split_(node))
    node.r = this.split_(node.r);
  return node;
};

// Traversal.
// There are two cases here. First, we can search for and retrieve a node with the
// given key (ultimately compared with `===`); and second, we can do an in-order
// traversal beginning at a given point. `search` returns the node associated with
// a key.

methods.search_ = function (node, k) {
  if (!node) return null;
  var tk = node.k;
  return k === tk        ? node
       : this.lt_(k, tk) ? this.search_(node.l, k)
       :                   this.search_(node.r, k);
};

// Traversal requires O(k + log n) comparisons, where k is the number of nodes
// that are in range.

methods.traverse_ = function (node, start, target) {
  if (!node) return;
  var k = node.k;
  if (start === void 0 || this.lt_(start, k)) {
    this.traverse_(node.l, start, target);
    if (target.push(node.v, k) === false) return false;
  }
  this.traverse_(node.r, start, target);
};

// Outer tree interface.
// The node class takes care of almost everything. We just need to manage the
// root.

methods.push_pair = function (v, k) {
  this.root_ = this.insert_(this.root_, v, k);
  this.first_ = this.last_ = null;
  return this;
};

methods.remove = function (k) {
  this.root_ = this.remove_(this.root_, k);
  this.first_ = this.last_ = null;
  return this;
};

methods.lookup = function (k) {
  var r = this.search_(this.root_, k);
  return r && r.v;
};

methods.first_node_ = function () {
  if (!this.root_) return null;
  var f = this.first_;
  if (f == null) {
    for (f = this.root_; f.l; f = f.l);
    this.first_ = f;
  }
  return f;
};

methods.first = function () {
  var f = this.first_node_();
  return f && f.v;
};

methods.kfirst = function () {
  var f = this.first_node_();
  return f && f.k;
};

methods.last_node_ = function () {
  if (!this.root_) return null;
  var l = this.last_;
  if (l == null) {
    for (l = this.root_; l.r; l = l.r);
    this.last_ = l;
  }
  return l;
};

methods.last = function () {
  var l = this.last_node_();
  return l && l.v;
};

methods.klast = function () {
  var l = this.last_node_();
  return l && l.k;
};

// Derivatives.
// Generators traverse the tree in key order, which involves maintaining a
// reference to the last one seen.

methods.derivative = function (generator) {
  var f = infuse.fn(generator);
  return infuse.aatree(this.lt_, f);
};

methods.generator_state = function () {return {last: void 0}};
methods.generate = function (target, state) {
  return this.root_ && this.root_.traverse(function (v, k) {
    if (target.push_pair(v, k) !== false) state.last = k;
    else                                  return false;
  });
};

});
});

// Generated by SDoc
module.exports = infuse;
