// Infuse AA-tree | Spencer Tipping
// Licensed under the terms of the MIT source code license

// Introduction.
// A straightforward AA-tree implementation used as a key modification journal by
// objects and buffers. Like heapmaps, AA-trees have generators that traverse the
// key/value pairs in value-sorted order.

infuse.extend(function (infuse) {
infuse.type('aatree', function (aatree, methods) {

infuse.mixins.pull(methods);

// AA-tree state.
// We store the ordering function, which takes two values and returns true if the
// first should be stored to the left of the second. When searching for elements,
// equality is determined with `===`.

// Storing AA-trees in an array is _completely and utterly impractical_, so we
// define a class representing a tree node.

methods.initialize = function (lt, use_strings, generator, base) {
  this.lt_        = lt ? infuse.fn(lt)
                       : function (a, b) {return a < b};
  this.root_      = null;
  this.map_       = use_strings ? {} : [];
  this.size_      = 0;
  this.version_   = -1;
  this.base_      = base;
  this.generator_ = generator;

  infuse.assert(!!base === !!generator,
    'infuse: base and generator must be specified together ('
  + 'error constructing aatree)');
};

methods.tos = function () {
  return (this.base_ ? '#t<' : '#<')
       + this.map('_2 + ": " + _1').join(', ')
       + '>';
};

methods.size = function () {return this.size_};

// Node state.
// Each node contains a key, value, level, left child, and right child. Nodes are
// not parent-linked.

methods.aatree_node_ = function (v, k, level, left, right) {
  this.v     = v;
  this.k     = k;
  this.level = level;
  this.left  = left;
  this.right = right;
};

// Rebalancing.
// Skew operation, which does this:

// |    L <- [T]              [L] -> T
//     / \      \     ->     /      / \
//    A   B      R          A      B   R

// The brackets indicate reference; for the skew operation, the parent's child
// pointer may change from T to L.

methods.aatree_node_.prototype.skew = function () {
  var l = this.left;
  if (l && l.level === this.level) {
    this.left = l.right;
    l.right   = this;
    return l;
  }
  return this;
};

// Split operation:

// |                           [R]
//      [T] -> R -> X         /   \
//     /      /         ->   T     X
//    A      B              / \
//                         A   B

// Just like in `skew`, we return the parent's new child.

methods.aatree_node_.prototype.split = function () {
  var r  = this.right;
  var rr = r && r.right;
  if (rr && this.level === rr.level) {
    this.right = r.left;
    r.left     = this;
    ++r.level;
    return r;
  }
  return this;
};

// Insertion.
// Destructively inserts a node into the tree.

methods.aatree_node_.prototype.insert = function (v, k, container) {
  // TODO
};

// Derivatives.
// Generators traverse the tree in value order, which involves maintaining a
// reference to the last value seen.

methods.derivative = function (generator, version_base) {
  var f = infuse.fn(generator);
  return infuse.aatree(this.lt_, !(this.map_ instanceof Array),
                       f, version_base || this);
};

methods.generator = function () {
  // TODO
};

});
});

// Generated by SDoc
