// Infuse buffers.
// See also the [Infuse buffer source](buffer-src.md).

// Like all Infuse objects, buffers support `size`, `get`, and a number of other
// accessor methods:

var xs = $i.buffer([1, 2, 3]);
infuse.assert_equal((xs.get(0)                      ), (1));
infuse.assert_equal((xs.get(-1)                     ), (3));
infuse.assert_equal((xs.tos()                       ), ('I[0:1, 1:2, 2:3]'));

// Buffers support the same kind of linear interpolation that arrays do:

infuse.assert_equal((xs.get(0.5)                    ), (1.5));

var quadratic = function (a, b, x) {return a + (b - a) * x*x};
infuse.assert_equal((xs.get(0.5, quadratic)         ), (1.25));
infuse.assert_equal((xs.get(0, quadratic)           ), (1));

// And without arguments, `get` returns a regular Javascript array:

infuse.assert_equal((xs.get()[0]                    ), (1));
infuse.assert_equal((xs.get().length                ), (3));

// Transformations.
// Buffers can be transformed just like arrays can:

var ys = xs.map('_ + 1');
var sum = xs.reduction(0, '_1 + _2');
infuse.assert_equal((ys.tos()                       ), ('#[0:2, 1:3, 2:4]'));
infuse.assert_equal((ys.version() > 0               ), (true));
infuse.assert_equal((sum.get()                      ), (6));

var t = xs.tail(2);
infuse.assert_equal((t.tos()                        ), ('#[... 2, 3]'));

// However, buffers are a little more flexible than arrays as they let you update
// previously-specified elements:

xs.push(10, 0);
infuse.assert_equal((ys.tos()                       ), ('#[0:11, 1:3, 2:4]'));
infuse.assert_equal((sum.get()                      ), (16));

// Obviously something is a little wrong with `reduction` as applied to the array.
// The problem here is that `reduction` applies to elements in update-order, which
// for normal arrays works like you would expect since all updates occur at the
// end. In general, it isn't possible to have a partially-lazy reduction over
// mutable collections.
// Generated by SDoc
