// Infuse utilities | Spencer Tipping
// Licensed under the terms of the MIT source code license

// Introduction.
// This module defines global functions on the `infuse` global.

infuse.extend(function (infuse) {

// Future constructors.
// Futures can be hard to work with on their own, so Infuse gives you some ways of
// wrapping them and combining their values.

infuse.immediate = function (v, k) {return infuse.future().push(v, k)};

// The `await` function is most useful when you have multiple futures running
// concurrently and want to wait for all of them to come back. It takes an object,
// array, or Infuse collection whose values may include futures and returns a
// future of a similarly-structured result whose values are all non-futures. That
// is, it transposes the future-ness of the values of some collection across the
// collection itself.

// Note that awaiting a collection of futures ignores the futures' keys.

infuse.await = function (xs) {
  var wrapped   = xs === (xs = infuse(xs)),
      root      = infuse.immediate([]),
      collector = xs.pairs().detach().reduce(root, function (f, p) {
        var v = p[0], k = p[1];
        return v instanceof infuse.future || v instanceof infuse.signal
          ? f.first().flatmap(function (pairs) {
              v.map(function (v) {
                pairs.push([v, k]);
                return pairs;
              });
            })
          : f.first().map(function (pairs) {
              pairs.push([v, k]);
              return pairs;
            });
      });

  return collector.map(function (pairs) {
    var g = infuse(pairs).generator();
    return xs.derivative(function (emit, id) {
      g(function (pair) {return emit(pair[0], pair[1])});
    });
  });
};

// Internal functions.
// These are generally just used by Infuse.

var id = 0;
infuse.gen_id = function () {return 'infuse-' + ++id};

infuse.toa   = function (xs)    {return Array.prototype.slice.call(xs)};
infuse.slice = function (xs, n) {return Array.prototype.slice.call(xs, n)};

infuse.fnarg = function (args, i) {
  // Make a function from arguments[i] and beyond. O(n) in the number of
  // arguments, though in most cases the GC overhead probably outweighs the
  // complexity.
  return infuse.fn.apply(this, infuse.slice(args, i));
};

infuse.assert = function (x, message) {
  if (!x) throw new Error(message);
  return x;
};

infuse.assert_equal = function (x, y) {
  infuse.assert(x === y, x + ' != ' + y);
  return x;
};

infuse.msb = function (x) {
  // Index of most-significant bit of x, where msb(1) = 0.
  for (var lower = 0, upper = 64; lower + 1 < upper;) {
    var mid     = lower + upper >>> 1,
        shifted = x >>> mid;
    if (shifted && shifted !== x) lower = mid;
    else                          upper = mid;
  }
  return lower;
};

});

// Generated by SDoc
