// Infuse pull-generator | Spencer Tipping
// Licensed under the terms of the MIT source code license

// Introduction.
// A pull generator is usually backed by an underlying collection of some sort.
// Consumers of pairs pull them by calling `into`.

infuse.extend(function (infuse) {
infuse.type('pull_generator', function (pull_generator, methods) {

infuse.mixins.pull(methods);

// Pull-generator state.
// Pull-generators maintain an opaque `state` object that is handed to the
// `generate` method of the generator's source.

methods.initialize = function (generator) {
  this.generator_ = generator;
  this.state_     = generator.generator_state();

  // This is a transient, sort-of-dynamically-scoped variable.
  this.target_ = null;
};

methods.version = function () {return this.generator_.version()};
methods.tos     = function () {return '#<' + this.generator_ + '>'};

methods.push_pair = function (v, k) {
  infuse.assert(this.target_ != null,
    'infuse: attempted to push a pair to a disconnected pull-generator ('
  + 'this sometimes means that you created a derivative collection that '
  + 'you never ended up using, or that you somehow connected a pull-generator '
  + 'to an asynchronous source)');
  return this.target_.push_pair(v, k);
};

// Generator fusion.
// There is some subtle stuff going on here. First, notice that pull generators
// appear to be pull collections. This enables you to transform generator outputs
// lazily, which bypasses intermediate collection allocations.

// Second, you can construct multiple derivatives of a generator. If you do this,
// each derivative will pick up where the original generator begins, and the
// derivatives will consume elements independently.

methods.generator       = function () {return this};
methods.generator_state = function () {return this.state_};

methods.generate = function (target, state) {
  infuse.assert(this.target_ == null,
    'infuse: attempted to make a re-entrant call to a generator (this can '
  + 'happen if you have a circular generator transformation topology and no '
  + 'intermediate buffering collections)');

  this.target_ = target;
  var result = this.generator_.generate(target, state);
  this.target_ = null;
  return result;
};

methods.derivative = function (generator) {
  return infuse.pull_generator(generator);
};

});
});

// Generated by SDoc
