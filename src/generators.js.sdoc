Infuse generators | Spencer Tipping
Licensed under the terms of the MIT source code license

Introduction.
Infuse uses generators to propagate values from source collections to
derivatives. A generator is an object that provides a few methods: `generate`,
`generator_state`, `version`, and `derivative`.

Collections are themselves generators, but Infuse also defines generators that
lazily transform values that originated somewhere else. Generators behave like
Infuse collections in that you can call `map`, `filter`, etc, on them to
construct derivatives.

infuse.extend(function (infuse) {

Generator metaclasses.
There are two fairly straightforward kinds of transforming generators. One, the
stateless generator, applies a consistent transformation to the key/value
space. The other, the nonreducing generator, transforms each pair
independently.

infuse.stateless_generator = function (name, transform) {
  return infuse.type(name, function (self, methods) {
    infuse.mixins.transforming_generator(methods);

    methods.initialize = function (generator) {
      this.generator_ = generator;
    };

    methods.transform = transform;
  });
};

infuse.nonreducing_generator = function (name, transform) {
  return infuse.type(name, function (self, methods) {
    infuse.mixins.transforming_generator(methods);

    methods.initialize = function (generator, f) {
      this.generator_ = generator;
      this.f_         = f;
    };

    methods.transform = transform;
  });
};

Stateless generators.
Fairly self-explanatory. There isn't a whole lot of interesting stuff that can
happen here.

infuse.stateless_generator('identity_generator',
  function (target, v, k) {return target.push_pair(v, k)});

infuse.stateless_generator('key_generator',
  function (target, v, k) {return target.push_pair(k, k)});

infuse.stateless_generator('inverse_generator',
  function (target, v, k) {return target.push_pair(k, v)});

Nonreducing generators.
These store a pair-transforming function `f_` that side-effectfully updates the
target with some transformation of the given (value, key) pair.

infuse.nonreducing_generator('map_generator',
  function (target, v, k) {return target.push_pair(this.f_(v, k), k)});

infuse.nonreducing_generator('filter_generator',
  function (target, v, k) {if (this.f_(v, k)) return target.push_pair(v, k)});

infuse.nonreducing_generator('mapfilter_generator',
  function (target, v, k) {
    var y = this.f_(v, k);
    if (y) return target.push_pair(y, k);
  });

infuse.nonreducing_generator('flatmap_generator',
  function (target, v, k) {
    var r = this.f_(v, k);
    return r && infuse(r).into(target);
  });

infuse.nonreducing_generator('kmap_generator',
  function (target, v, k) {return target.push_pair(v, this.f_(k, v))});

infuse.nonreducing_generator('kmapfilter_generator',
  function (target, v, k) {
    var j = this.f_(k, v);
    if (j) return target.push_pair(v, j);
  });

infuse.nonreducing_generator('keygate_generator',
  function (target, v, k) {
    if (this.f_(k)) return target.push_pair(v, k);
  });

Reducing generators.
These maintain state between `transform` calls, which makes order more
important.

infuse.type('reduction_generator', function (gen, methods) {
  infuse.mixins.transforming_generator(methods);

  methods.initialize = function (generator, initial, f) {
    this.generator_ = generator;
    this.v_         = initial;
    this.f_         = f;
  };

  methods.transform = function (target, v, k) {
    return target.push_pair(this.v_ = this.f_(this.v_, v, k), k);
  };
});

Collapsing generators are an even more versatile form: they are allowed to
remove values from the incoming stream (or join them in arbitrary ways). This
is different from `reduction_generator`s, which simply combine previous values
with new ones.

infuse.type('collapsing_generator', function (gen, methods) {
  infuse.mixins.transforming_generator(methods);

  methods.initialize = function (generator, state, f) {
    this.generator_ = generator;
    this.state_     = state;
    this.transform  = f;
  };
});

});
