Infuse caches | Spencer Tipping
Licensed under the terms of the MIT source code license

Introduction.
This module defines various kinds of caches for Infuse. These are used
internally in cases where a weak reference map would ordinarily be used; for
instance, caching compiled functions.

infuse.extend(function (infuse) {

infuse.cache = function (eviction_strategy) {
  var cache = {},       // cache data
      state = {};       // eviction strategy state
  eviction_strategy = eviction_strategy || infuse.cache.lru();
  var result = function (obj, generate) {
    return eviction_strategy(result, cache, state, obj, generate);
  };
  result(null, null);   // initialize the cache
  return result;
};

Eviction strategies.
An eviction strategy is notified whenever an entry is created, accessed, added,
or removed from the cache. It then, potentially asynchronously, acts on the
cache object to evict something if necessary. The eviction strategy owns the
cache object exclusively; no user of the cache has access to it.

  LRU eviction.
  This is the most straightforward. We just keep a simple mapping from key to
  access-time, and maintain a priority queue of evictable elements. This makes
  cache access O(log n) in the number of elements, which is bounded above by
  the cache capacity.

  LRU eviction allows the user to evict an element at any point by calling the
  `evict_one` method on the cache object. This can be useful if you want to
  simulate weak references by slowly freeing memory over time, for instance.

  infuse.cache.lru = function (options) {
    options = options || {};
    var capacity = options.capacity || 1000,
        evict    = function (cache, state) {
          // Do nothing if there are no elements.
          if (!state.size) return false;
          --state.size;
          return delete cache[state.priority_queue.pop()];
        },
        clear    = function (cache, state) {
          for (var k in cache) delete cache[k];
          while (state.priority_queue.size()) state.priority_queue.pop();
          state.size = 0;
        };

    return function (f, cache, state, key, generate) {
      // Initialize the state if necessary. This happens before any objects are
      // inserted into the cache.
      if (key === null && generate === null) {
        state.size           = 0,
        state.access_counter = 0,
        state.priority_queue = new infuse.heapmap(),
        f.hits               = 0,
        f.evictions          = 0,
        f.misses             = 0,
        f.evict_one          = function () {return evict(cache, state)},
        f.clear              = function () {return clear(cache, state)};
        return null;
      }

      // Prefix the key with something not used by Javascript. Otherwise we
      // risk colliding with native methods like Object.prototype.toString.
      key = '@' + key;

      // First, determine whether we have the item. If we do, just update the
      // access time and take no further action.
      var hit = cache[key];
      if (hit) {
        ++f.hits;
        state.priority_queue.push(key, ++state.access_counter);
        return hit;
      }

      // Cache miss, so go ahead and generate a value and insert the result.
      // If we're over capacity, evict the least-recent access, which will be
      // the top element in the priority queue.
      var value = generate(key);
      ++f.misses;
      if (++state.size > capacity) {
        ++f.evictions;
        evict(cache, state);
      }
      state.priority_queue.push(key, ++state.access_counter);
      return cache[key] = value;
    };
  };

});
