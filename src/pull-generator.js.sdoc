Infuse pull-generator | Spencer Tipping
Licensed under the terms of the MIT source code license

Introduction.
A pull generator is usually backed by an underlying collection of some sort.
Consumers of pairs pull them by calling `into`.

infuse.extend(function (infuse) {
infuse.type('pull_generator', function (pull_generator, methods) {

infuse.mixins.pull(methods);

Pull-generator state.
Pull-generators maintain an opaque `state` object that is handed to the
`generate` method of the generator's source.

methods.initialize = function (generator) {
  this.generator_ = generator;
  this.state_     = generator.generator_state();

  // This is a transient, sort-of-dynamically-scoped variable.
  this.target_ = null;
};

methods.version = function () {return this.generator_.version()};
methods.tos     = function () {return '#<' + this.generator_ + '>'};

methods.push_pair = function (v, k) {
  infuse.assert(this.target_ != null,
    'infuse: attempted to push a pair to a disconnected pull-generator ('
  + 'this sometimes means that you created a derivative collection that '
  + 'you never ended up using, or that you somehow connected a pull-generator '
  + 'to an asynchronous source)');
  return this.target_.push_pair(v, k);
};

Generator fusion.
There is some subtle stuff going on here. First, notice that pull generators
appear to be pull collections. This enables you to transform generator outputs
lazily, which bypasses intermediate collection allocations.

Second, you can construct multiple derivatives of a generator. If you do this,
each derivative will pick up where the original generator begins, and the
derivatives will consume elements independently.

methods.generator       = function () {return this};
methods.generator_state = function () {return this.state_};

methods.generate = function (target, state) {
  infuse.assert(this.target_ == null,
    'infuse: attempted to make a re-entrant call to a generator (this can '
  + 'happen if you have a circular generator transformation topology and no '
  + 'intermediate buffering collections)');

  this.target_ = target;
  var result = this.generator_.generate(target, state);
  this.target_ = null;
  return result;
};

methods.derivative = function (generator) {
  return infuse.pull_generator(generator);
};

});
});
